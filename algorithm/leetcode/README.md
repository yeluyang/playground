# 算法题笔记

[TOC]

- [26.删除有序数组中的重复项](questions/accepted/26.删除有序数组中的重复项.rs)：
  - 任务：【去重】
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
    - 【有序】因为数组是有序的，重复项必定相邻
  - 解法
    - 【双指针】Time=O(n), Space=O(1)
      - 将数组分割成两部分，前一部分不重复，后一部分可能重复
      - 左指针指向不重复数组的末端，左指针之前没有重复，之后可能存在重复
      - 右指针向前探索不断寻找左指针之前没有的值，然后将其加入左指针之前的数组，左指针则配合着前进一步来扩大不重复数组范围

- [122.买卖股票的最佳时机-ii](questions/optimizable/122.买卖股票的最佳时机-ii.rs)
  - 任务：【求最值/最大值】题目任务是求最大值任务
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 解法
    - 【动态规划/贪心法】Time=O(n), Space=O(1)
      - 对数组每个元素检查是否比下一元素小
      - 若是，则将二者的差累加到返回值

- [189.旋转数组](questions/wrong/189.旋转数组.rs)
  - 任务：TODO
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 解法
    - 【数组翻转】Time=O($\log_2n$), Space=O(1)
      - 翻转整个数组
      - 翻转数组`[0, k)`的切片
      - 翻转数组`[k, n)`的切片
    - 【环状替换】Time=O(n), Space=O(1)

- [217.存在重复元素](questions/accepted/217.存在重复元素.rs)
  - 任务：TODO
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 解法
    - 【哈希】Time=O(n), Space=O(n)
      - 对每个元素，将其插入集合中，若发现集合中已存在，则存在重复元素

- [136.只出现一次的数字](questions/wrong/136.只出现一次的数字.rs)
  - 任务：TODO
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
    - 【偶数次重复】重复元素都重复两次
    - 【不重复元素唯一】不重复元素只有一个
  - 解法
    - 【数学：异或位运算】Time=O(n), Space=O(1)
      - 异或位运算有如下性质：
        - $ a \oplus 0 = a $
        - $ a \oplus a = 0 $
        - $ a \oplus b = b \oplus a $
        - $ a \oplus b \oplus c = a \oplus (b \oplus c) $
      - 将整个数组所有元素一起进行异或运算，据异或位运算的性质，可以过滤掉数组内所有偶数次重复的元素，留下唯一不重复的元素：

        $ a \oplus b \oplus a = (a \oplus a) \oplus b = 0 \oplus b = b $

- [350.两个数组的交集-ii](questions/accepted/350.两个数组的交集-ii.rs)
  - 任务：TODO
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 解法
    - 【哈希】Time=O(m + n), Space=O( min(m, n) )
      - 使用以元素值为键，出现次数为值的哈希表
      - 遍历较短的数组，记录每个元素的出现次数
      - 遍历另一数组，对存在于哈希表中的元素，将元素记录到返回结果中，并将次数-1。若次数-1后为0，则从哈希表移除该元素

- [66.加一](questions/accepted/66.加一.rs)
  - 任务：TODO
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 解法
    - 【逆序遍历】Time=O(n), Space=O(1)
      - 从数组尾部向前进行逆序遍历：
        - 当前元素=9，则置0
        - 当前元素<9，则+1，并返回
      - 遍历结束意味着该数字每一位都是9，则分配一个size+1的数组，并将数组首位置1，其余元素置0，然后返回该新数组

- [283.移动零](questions/accepted/283.移动零.rs)
  - 任务：TODO
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 解法
    - 【双指针】Time=O(n), Space=O(1)
      - 将数组分割成两部分，前一部分没有0，后一部分可能有0
      - 左指针指向非0数组的末端，左指针之前没有0，之后可能存在0
      - 右指针向前探索不断寻找非0值，然后将其加入左指针之前的数组，左指针则配合着前进一步来扩大不重复数组范围

- [1.两数之和](questions/accepted/1.两数之和.rs)
  - 任务：TODO
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 解法
    - 【哈希】Time=O(n), Space=O(n)
      - 构建一个以元素值为键，元素值下标为值的哈希表
      - 遍历每个元素，计算目标值减去元素的差值是否在表中：
        - 若存在，则返回该键的值与当前元素下标值组成的二元组
        - 若不存在，则插入以元素值为键，元素下标为值的键值对入表

- [36.有效的数独](questions/accepted/36.有效的数独.rs)
  - 任务：TODO
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 解法
    - 【哈希】+【状态位串】Time=O(a * a), Space=O(a + a + a)
      - 构建三个哈希表：
        - 行哈希表：以行号为键，以位数大于等于列数a的位串为值
        - 列哈希表：以列号为键，以位数大于等于行数a的位串为值
        - 宫哈希表：以宫号为键，以位数大于等于宫数a的位串为值
      - 遍历矩阵每个元素(i,j)：
        - 将1按位右移，偏移量等于该元素值，所得结果作为元素模式
        - 元素模式与行哈希表第i行对应的位串按位与操作：
          - 结果==0：将元素模式以按位或操作的方式更新到行哈希表第i行对应的位串
          - 结果!=0：判别为无效数独并返回结果
        - 元素模式与列哈希表第j列对应的位串按位与操作：
          - 结果==0：将元素模式以按位或操作的方式更新到列哈希表第j列对应的位串
          - 结果!=0：判别为无效数独并返回结果
        - 元素模式与宫哈希表第(i/3+j/3)宫对应的位串按位与操作：
          - 结果==0：将元素模式以按位或操作的方式更新到宫哈希表第(i/3+j/3)宫对应的位串
          - 结果!=0：判别为无效数独并返回结果

- [48.旋转图像](questions/wrong/48.旋转图像.rs)
  - 任务：TODO
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 解法
    - 【先上下翻转，再对角线翻转】Time=O($n\log_2n$) Space=O(1)
      - 以矩阵中间为对称轴，上下翻转矩阵
      - 以对角线为对称轴，翻转矩阵

- [344.反转字符串](questions/accepted/344.反转字符串.rs)
  - 任务：TODO
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 解法
    - 【双指针】Time=O(n), Space=O(1)
      - 左指针从数组头开始，右指针从数组尾开始
      - 交换两个指针所指的值
      - 左指针向尾移动一步，右指针向头移动一步

- [7.整数反转](questions/wrong/7.整数反转.rs)
  - 任务：TODO
  - 条件
    - 【32位】算法运行环境是32位环境，每次计算不准有多于32位的数据
  - 解法
    - 【数学：溢出判断】Time=O(n), Space=O(1)
      - 要保证翻转后的数字不会溢出，只要如下不等式成立即可：
        $ -2^{31} \leq reverse \times 10 + digit \leq 2^{31}-1 $
        该不等式可以简化为:
        $ \lceil \frac{-2^{31}}{10} \rceil \leq reverse \leq \lfloor \frac{2^{31}-1}{10} \rfloor $
      - 使用求模再除10的方法，从最低位逐位取出该位数值
      - 再使用乘10后相加的方法，把该数值添加到反转数当前的最低位上
      - 使用上面的简化后的不等式判定反转数的当前值，不符合判定则返回错误
    - 【逆运算还原检查】Time=O(n), Space=O(1)
      - 使用求模再除10的方法，从最低位逐位取出该位数值
      - 再使用乘10后相加的方法，把该数值添加到反转数当前的最低位上
      - 对当前反转数做上一步的逆运算，检查逆运算结果是否与反转数的上一数值等同。若不等同意味着有溢出，返回错误

- [387.字符串中的第一个唯一字符](questions/accepted/387.字符串中的第一个唯一字符.rs)
  - 任务：TODO
  - 条件
    - 【ASCII字符串】
  - 解法
    - 【哈希】Time=O(n), Space=O($\Sigma$)
      - 构建一个以元素值为键，元素出现次数为值的哈希表
      - 遍历字符串，统计元素出现次数到哈希表中
      - 遍历哈希表，遇到次数为1的元素记录就返回结果

- [242.有效的字母异位词](questions/optimizable/242.有效的字母异位词.rs)
  - 任务：TODO
  - 条件
    - 【ASCII字符串】
  - 解法
    - 【哈希】Time=O(n), Space=O($\Sigma$)
      - 构建一个以字符值为键，字符出现次数为值的哈希表
      - 遍历其中一个字符串，将字符出现频次统计入哈希表
      - 遍历另一个字符串：
        - 字符值不在哈希表中，则不是异位词，返回结果
        - 字符值在哈希表中则对应的出现次数-1，若-1后为0，则移除该键值对
      - 遍历结束后，若哈希表为空，则为异位词

- [125.验证回文串](questions/accepted/125.验证回文串.rs)
  - 任务：TODO
  - 条件
    - 【ASCII字符串】
  - 解法
    - 【双指针】Time=O($log_2n$), Space=O(1)
      1. 左指针指向字符串头，右指针指向字符串尾，左右指针相向移动，步长为1
      1. 左右指针都跳过非字母的字符
      1. 检查左右指针指向的字符值是否相等
         - 若相等，左右指针移动一步，回到(2)
         - 若不等，则不是回文串，返回结果
      1. 重复(2)(3)直到左指针和右指针相等或交错

- [8.字符串转换整数-atoi](questions/wrong/8.字符串转换整数-atoi.rs)
  - 任务：TODO
  - 条件
    - 【ASCII字符串】
  - 解法
    - 【确定有限状态机 + 数学：溢出判断】Time=O(n), Space=O(1)
      - 初始状态：
        - 遍历到空格不做处理
        - 遍历到数字转移到“数字状态”
        - 遍历到正负号转移到“符号状态”
        - 遍历到其他字符转移到“结束状态”
      - 数字状态：
        - 遍历到非数字转移到“结束状态”
        - 遍历到数字则推入最终结果，并做溢出判断
      - 符号状态：
        - 遍历到数字则转移到“数字状态”
        - 遍历到非数字则转移到“结束状态”
      - 结束状态：返回最终结果与符号

- [28.实现-str-str](questions/wrong/28.实现-str-str.rs)
  - 任务：TODO
  - 条件
    - 【ASCII字符串】
  - 解法
    - 【子串匹配：KMP算法】

- [38.外观数列](questions/accepted/38.外观数列.rs)
  - 任务：TODO
  - 条件
  - 解法
    - 【字符串遍历】

- [14.最长公共前缀](questions/optimizable/14.最长公共前缀.rs)
  - 任务：TODO
  - 条件
    - 【字符串数组】
  - 解法
    - 【矩阵横向查找】
      - 步骤
        1. 以矩阵第一行作为前缀模式初值
        1. 以行遍历的方式从第二行开始逐字符匹配：
           - 相等：比对下一字符
           - 不等：比对下一行
        1. 遍历结束后，返回前缀模式
      - 复杂度
        - 时间：
          - O(m*n)，n是字符串数量，m是字符串平均长度
          - 在内存以行存储矩阵且共同前缀较长时，性能优于其他方法
        - 空间：O(1)
    - 【矩阵纵向查找】
      - 步骤
        1. 以列遍历的方式检查字符矩阵每一列是否相等：
           - 相等：检查下一列
           - 不等：返回任一行的0列到前一列的内容为最终结果
      - 复杂度
        - 时间：
          - O(m*n)，n是字符串数量，m是字符串平均长度
          - 在内存以列存储或者共同前缀非常短时，性能优于其他方法
        - 空间：O(1)
