# 算法题笔记

[TOC]

- [189.旋转数组](questions/wrong/189.旋转数组.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：TODO
  - 解法
    - 【数组翻转】Time=O($\log_2n$), Space=O(1)
      - 翻转整个数组
      - 翻转数组`[0, k)`的切片
      - 翻转数组`[k, n)`的切片
    - 【环状替换】Time=O(n), Space=O(1)

- [136.只出现一次的数字](questions/wrong/136.只出现一次的数字.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
    - 【偶数次重复】重复元素都重复两次
    - 【不重复元素唯一】不重复元素只有一个
  - 分析：TODO
  - 解法
    - 【数学：异或位运算】Time=O(n), Space=O(1)
      - 异或位运算有如下性质：
        - $ a \oplus 0 = a $
        - $ a \oplus a = 0 $
        - $ a \oplus b = b \oplus a $
        - $ a \oplus b \oplus c = a \oplus (b \oplus c) $
      - 将整个数组所有元素一起进行异或运算，据异或位运算的性质，可以过滤掉数组内所有偶数次重复的元素，留下唯一不重复的元素：

        $ a \oplus b \oplus a = (a \oplus a) \oplus b = 0 \oplus b = b $

- [66.加一](questions/accepted/66.加一.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：TODO
  - 解法
    - 【逆序遍历】Time=O(n), Space=O(1)
      - 从数组尾部向前进行逆序遍历：
        - 当前元素=9，则置0
        - 当前元素<9，则+1，并返回
      - 遍历结束意味着该数字每一位都是9，则分配一个size+1的数组，并将数组首位置1，其余元素置0，然后返回该新数组

- [48.旋转图像](questions/wrong/48.旋转图像.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：TODO
  - 解法
    - 【先上下翻转，再对角线翻转】Time=O($n\log_2n$) Space=O(1)
      - 以矩阵中间为对称轴，上下翻转矩阵
      - 以对角线为对称轴，翻转矩阵

- [7.整数反转](questions/wrong/7.整数反转.rs)
  - 条件
    - 【32位】算法运行环境是32位环境，每次计算不准有多于32位的数据
  - 分析：TODO
  - 解法
    - 【数学：溢出判断】Time=O(n), Space=O(1)
      - 要保证翻转后的数字不会溢出，只要如下不等式成立即可：
        $ -2^{31} \leq reverse \times 10 + digit \leq 2^{31}-1 $
        该不等式可以简化为:
        $ \lceil \frac{-2^{31}}{10} \rceil \leq reverse \leq \lfloor \frac{2^{31}-1}{10} \rfloor $
      - 使用求模再除10的方法，从最低位逐位取出该位数值
      - 再使用乘10后相加的方法，把该数值添加到反转数当前的最低位上
      - 使用上面的简化后的不等式判定反转数的当前值，不符合判定则返回错误
    - 【逆运算还原检查】Time=O(n), Space=O(1)
      - 使用求模再除10的方法，从最低位逐位取出该位数值
      - 再使用乘10后相加的方法，把该数值添加到反转数当前的最低位上
      - 对当前反转数做上一步的逆运算，检查逆运算结果是否与反转数的上一数值等同。若不等同意味着有溢出，返回错误

- [8.字符串转换整数-atoi](questions/wrong/8.字符串转换整数-atoi.rs)
  - 条件
    - 【ASCII字符串】
  - 分析：TODO
  - 解法
    - 【确定有限状态机 + 数学：溢出判断】Time=O(n), Space=O(1)
      - 初始状态：
        - 遍历到空格不做处理
        - 遍历到数字转移到“数字状态”
        - 遍历到正负号转移到“符号状态”
        - 遍历到其他字符转移到“结束状态”
      - 数字状态：
        - 遍历到非数字转移到“结束状态”
        - 遍历到数字则推入最终结果，并做溢出判断
      - 符号状态：
        - 遍历到数字则转移到“数字状态”
        - 遍历到非数字则转移到“结束状态”
      - 结束状态：返回最终结果与符号

- [28.实现-str-str](questions/wrong/28.实现-str-str.rs)
  - 条件
    - 【ASCII字符串】
  - 分析：TODO
  - 解法
    - 【子串匹配：KMP算法】

- [38.外观数列](questions/accepted/38.外观数列.rs)
  - 条件
  - 分析：TODO
  - 解法
    - 【字符串遍历】

- [14.最长公共前缀](questions/optimizable/14.最长公共前缀.rs)
  - 条件
    - 【字符串数组】
  - 分析：TODO
  - 解法
    - 【矩阵横向查找】
      - 步骤
        1. 以矩阵第一行作为前缀模式初值
        1. 以行遍历的方式从第二行开始逐字符匹配：
           - 相等：比对下一字符
           - 不等：比对下一行
        1. 遍历结束后，返回前缀模式
      - 复杂度
        - 时间：
          - O(m*n)，n是字符串数量，m是字符串平均长度
          - 在内存以行存储矩阵且共同前缀较长时，性能优于其他方法
        - 空间：O(1)
    - 【矩阵纵向查找】
      - 步骤
        1. 以列遍历的方式检查字符矩阵每一列是否相等：
           - 相等：检查下一列
           - 不等：返回任一行的0列到前一列的内容为最终结果
      - 复杂度
        - 时间：
          - O(m*n)，n是字符串数量，m是字符串平均长度
          - 在内存以列存储或者共同前缀非常短时，性能优于其他方法
        - 空间：O(1)

- [237.删除链表中的节点](questions/wrong/237.删除链表中的节点.c)
  - 条件
    - 【单链表】单链表数据结构，可以顺序访问，不能随机访问，不能逆序访问。任何位置的插入删除操作开销都很低
    - 【从中间开始】只给出指定要删除节点且保证不是尾节点，不给出链表头节点
  - 分析：TODO
  - 解法
    - 【TODO】Time=O(1), Space=O(1)
      1. 将指定节点的下一节点的值赋给指定节点
      1. 将指定节点的下一节点的next赋给指定节点
      1. 将指定节点的下一节点作为要删除的节点，删除释放掉

- [19.删除链表的倒数第-n-个结点](questions/accepted/19.删除链表的倒数第-n-个结点.rs)
  - 条件
    - 【单链表】单链表数据结构，可以顺序访问，不能随机访问，不能逆序访问。任何位置的插入删除操作开销都很低
  - 分析：TODO
  - 解法
    - 【快慢指针】Time=O(n), Space=O(1)
      1. 快指针前进n步后，慢指针再开始前进，保持快指针领先慢指针n个节点
      1. 快指针遍历完链表成为空指针时，慢指针就指向了倒数第n个节点，删除慢指针指向的节点即可

- [206.反转链表](questions/accepted/206.反转链表.rs)
  - 条件
    - 【单链表】单链表数据结构，可以顺序访问，不能随机访问，不能逆序访问。任何位置的插入删除操作开销都很低
  - 分析：TODO
  - 解法
    - 【TODO】Time=O(n), Space=O(1)
      1. 设置3个指针，cur指向当前要翻转的节点，next指向cur的下一节点，pre指向cur的前一节点
      1. 设置cur指针的next指向pre
      1. 更新pre指向cur
      1. 更新cur指向next
      1. 更新next指向cur.next
      1. 回到(2)，重复直到cur为空

- [21.合并两个有序链表](questions/accepted/21.合并两个有序链表.rs)
  - 条件
    - 【单链表】单链表数据结构，可以顺序访问，不能随机访问，不能逆序访问。任何位置的插入删除操作开销都很低
    - 【有序】两个单链表的节点值是升序的
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 算法
        1. 创建一个新的链表头节点
        1. 两个链表中的较小的头节点取出来加入到新链表
        1. 回到(2)，重复直到其中一个链表为空
        1. 将另一个不空的链表整个添加到新链表
        1. 返回新链表
      - 复杂度
        - 时间：O(m + n)，“m”和“n”是两个链表的长度
        - 空间：O(1)

- [234.回文链表](questions/wrong/234.回文链表.rs)
  - 条件
    - 【单链表】单链表数据结构，可以顺序访问，不能随机访问，不能逆序访问。任何位置的插入删除操作开销都很低
  - 分析
    - 【TODO】
  - 解法
    - 【快慢指针】
      - 分析
        - 【快慢指针步长倍数是遍历元素数量的倍数】快慢指针步长的倍数为n，则当快指针遍历全部元素时，慢指针恰好遍历完1/n的元素
      - 步骤
        1. 设置快慢指针同时从头节点出发向尾节点前进
        1. 遍历链表并更新快慢指针：
           - 快指针每次前进两步，同时累加链表节点计数
           - 慢指针每次前进一步，每次离开一个节点前，先反转该节点的next指向原来的前序节点
        1. 重复(2)，直到快指针到尾节点，此时，慢指针正好在链表中间，而链表前半部分则被翻转：
        1. 快指针重置为慢指针的next
        1. 根据链表节点数量的奇偶性分别处理
           - 链表节点数为偶数：不做处理
           - 链表节点数为奇数：
             1. 慢指针重置为前一个节点
        1. 快指针向尾节点前进，慢指针向头节点前进，两指针每次前进一步：
           1. 修复该节点被慢指针修改的next
           1. 检查节点值：
            - 节点值相等：继续前进
            - 节点值不等：修复剩余被慢指针修改的链表顺序，然后返回无效回文判定
      - 复杂度
        - 时间：O(n)
        - 空间：O(1)
    - 【全局变量递归】
      - 分析
        - 【TODO】
      - 步骤
        1. 设置一个指向头节点的全局变量后，开始递归
        1. 从头节点开始递归处理：
           1. 检查当前节点是否为空节点：
              - 空节点：返回有效回文判定
              - 非空节点：递归处理该节点的next节点，并检查其返回的判定是不是有效回文：
                - 无效回文：直接返回无效回文的判定
                - 有效回文：
                  1. 检查当前节点与全局节点的值是否相等：
                     - 相等：更新全局节点指向其next节点，然后返回有效回文判定
                     - 不等：直接返回无效回文判定
      - 复杂度
        - 时间：O(n)
        - 空间：O(1)

- [141.环形链表](questions/wrong/141.环形链表.c)
  - 条件
    - 【单链表】单链表数据结构，可以顺序访问，不能随机访问，不能逆序访问。任何位置的插入删除操作开销都很低
  - 分析
    - 【TODO】
  - 解法
    - 【快慢指针】
      - 分析
        - 【TODO】
      - 步骤
        1. 设置快慢指针同时从头节点出发向尾节点前进
        1. 使用快慢指针遍历链表：
           1. 快指针每次前进两步，并检查遍历过的两个节点是否被慢指针指向：
              1. 是慢指针指向：返回有环的判定
              1. 不是慢指针指向：继续遍历
           1. 慢指针每次前进一步
        1. 重复(2)，直到快指针遍历到链表尾节点时返回无环的判定
      - 复杂度
        - 时间：O(n)
        - 空间：O(1)

- [104.二叉树的最大深度](questions/accepted/104.二叉树的最大深度.rs)
  - 条件
    - 【二叉树】TODO
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 步骤
        1. 检查当前递归节点是否为空：
           - 空：返回深度=0
           - 非空：
              1. 递归计算左子树深度
              1. 递归计算右子树深度
              1. 取左右子树最大深度值，加一后返回
      - 复杂度
        - 时间：O(n)
        - 空间：O($log_2n$)
    - 【广度优先遍历】
      - 步骤
        1. 广度优先遍历时，每次都先把队列内所有节点全部出队再遍历。这样能保证任意时刻队列内的节点都处于统一深度
      - 复杂度
        - 时间：O(n)
        - 空间：O($log_2n$)
    - 【深度优先遍历】
      - 步骤
        1. 使用双栈，并在深度优先遍历时，每次节点入栈都把该节点深度同步入另一个栈
      - 复杂度
        - 时间：O(n)
        - 空间：O($log_2n$)

- [98.验证二叉搜索树](questions/wrong/98.验证二叉搜索树.rs)
  - 条件
    - 【二叉树】TODO
    - 【有序】TODO
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 步骤
      1. 使用值域区间来递归处理每个节点：
         1. 检查当前节点是否处于区间内：
            - 否：返回无效搜索树判定
            - 是：
              1. 递归处理左子树，并将值域区间的下限保留，上限改为自身值
              1. 递归处理右子树，并将值域区间的上限保留，下限改为自身值
      - 复杂度
        - 时间：O(n)
        - 空间：O($nlog_2n$)
    - 【中序遍历】
      - 分析
        - 【TODO】
      - 步骤
        1. 中序遍历过程中：
           1. 出栈前先记录当前节点为pre
           1. 出栈后检查出栈节点是否大于pre：
              1. 否：返回无效搜索树判定
              1. 是：检查出站节点是否小于其右子节点：
                 1. 否：返回无效搜索判定
                 1. 是：继续中序遍历
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [101.对称二叉树](questions/wrong/101.对称二叉树.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 步骤
        1. 从根节点的左右子节点开始递归
        1. 每次递归同时处理两个节点：
           1. 两个节点是否有空结点：
              - 两个都是空：返回有效对称判定
              - 仅有一个空：返回无效对称判定
              - 两个都非空：检查两个节点值是否相等：
                - 不等：返回无效对称判定
                - 相等：
                  1. 递归处理左节点的左子树和右节点的右子树
                  1. 递归处理左节点的右子树和右节点的左子树
      - 复杂度
        - 时间：O($log_2n$)
        - 空间：O(TODO)

- [102.二叉树的层序遍历](questions/accepted/102.二叉树的层序遍历.rs)
  - 条件
    - 【二叉树】TODO
  - 分析
    - 【TODO】
  - 解法
    - 【广度优先遍历】
      - 步骤
        1. 广度优先遍历时，每次都先把队列内所有节点全部出队再遍历。这样能保证任意时刻队列内的节点都处于统一深度
      - 复杂度
        - 时间：O(n)
        - 空间：O($log_2n$)

- [108.将有序数组转换为二叉搜索树](questions/wrong/108.将有序数组转换为二叉搜索树.rs)
  - 条件
    - 【二叉树】
    - 【有序】
  - 分析
    - 【TODO】
  - 解法
    - 【分治】
      - 分析
        - 【TODO】
      - 步骤
        1. 递归处理整个数组
        1. 每次递归：
           1. 取数组最中间元素作树根
           1. 递归处理数组左半部分得到左子树根并更新到根上
           1. 递归处理数组右半部分得到右子树根并更新到根上
           1. 向上一层返回树根
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [88.合并两个有序数组](questions/wrong/88.合并两个有序数组.rs)
  - 条件
    - 【数组】
    - 【有序】
  - 分析
    - 【TODO】
  - 解法
    - 【尾部归并排序】
      - 分析
        - 【TODO】
      - 步骤
        1. 从两数组尾部元素开始比较，较大的元素填入第一个数组的尾部空间
        1. 其中一个数组被全部比较完后，另一数组余下元素直接填充结果
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [278.第一个错误的版本](questions/wrong/278.第一个错误的版本.rs)
  - 条件
    - 【数组】
    - 【有序】
  - 分析
    - 【TODO】
  - 解法
    - 【二分查找（改）】
      - 分析
        - 【TODO】
      - 步骤
        1. 从中间元素开始二分查找：
           1. API返回false则向后查找
           1. API返回true则向前查找
        1. 全部元素查找完后，返回二分查找的左边界
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [70.爬楼梯](questions/wrong/70.爬楼梯.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【可分治】问题的解可由子问题的解组合而来
  - 解法
    - 【动态规划】
      - 分析
        - 【TODO】
      - 步骤
        1. 检查n是否小于等于1：
           - 是：返回1
           - 否：
             1. 递归计算n-1阶的结果
             1. 递归计算n-2阶的结果
             1. 将两个递归结果相加并返回
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【动态规划+记忆化搜索】+【记忆简化】
      - 分析
        - 【TODO】
      - 步骤
        1. 设置变量v0=1，表示爬0级台阶有1种方法；设置变量v1=1，表示爬1级台阶有1种方法
        1. 要爬n级台阶则迭代n-2次，每次迭代：
           1. 设置临时变量，值等于v0+v1
           1. 将v1的值赋给v0
           1. 将临时变量的值赋给v1
        1. 返回v0+v1的和
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【动态规划+数学建模：矩阵快速幂】
      - 分析
        - 【齐次线性递推式】
          - 动态规划递推式为：$f(n) = f(n-1) + f(n-2)$，这是齐次线性方程，可以直接转换为矩阵递推式：

            $
            \begin{bmatrix}
            f(n+1) \\
            f(n)
            \end{bmatrix} = \begin{bmatrix}
            f(n) + f(n-1) \\
            f(n)
            \end{bmatrix} = \begin{bmatrix}
            1 & 1 \\
            1 & 0
            \end{bmatrix} \begin{bmatrix}
            f(n) \\
            f(n-1)
            \end{bmatrix} = \begin{bmatrix}
            1 & 1 \\
            1 & 0
            \end{bmatrix}^n \begin{bmatrix}
            f(1) \\
            f(0)
            \end{bmatrix}
            $

          - 根据以上递推式结果，可以使用快速幂来求系数矩阵，从而求出$f(n)$，即爬n级有多少种方法的解

      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【动态规划+数学建模：通项公式】
      - 分析
        - 【TODO】
          - 对任意的$a_{n+2} = pa_{n+1} + qa_n$，都可以令$a_n = x^n$代入求得$x^2 = px + q$。该性质对$f(n) = f(n-1) + f(n-2)$也是成立的
          - 令$f(n) = x^n$，可得$x^2 = x + 1$，求解得$x_1 = \frac{1 + \sqrt{5}}{2}$，$x_2 = \frac{1 - \sqrt{5}}{2}$
          - 设通解为$f(n) = c_1 x^n_{1} + c_2 x^n_{2}$，代入递推初始条件$f(0) = 1$和$f(1) = 1$，可得$c_1 = \frac{1}{\sqrt{5}}$，$c_2 = -\frac{1}{\sqrt{5}}$
          - 则$f(n) = \frac{1}{\sqrt{5}} \left[ \left( \frac{1 + \sqrt{5}}{2} \right)^n - \left( \frac{1 - \sqrt{5}}{2} \right)^n \right]$
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [121.买卖股票的最佳时机](questions/wrong/121.买卖股票的最佳时机.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【动态规划+记忆化搜索】+【记忆简化】
      - 分析
        - 【TODO】
          - 对于任意交易日来说，当日只有两种情况：
            - 无头寸：无头寸时又有两种情况：
              - 今日卖出：该情况下，利润就是前一交易日的“有头寸”的利润加上今日卖出所得的利润
              - 今日无交易：这意味着前一交易日就没有头寸。该情况下，利润就是前一交易日的“无头寸”的利润
            - 有头寸：有头寸时又有两种情况：
              - 今日买入：该情况下，利润就是当日股票价格的负数，因为买入股票意味着账面暂时损失了买入价格，在卖出之前，利润都是负的
              - 今日无交易：这意味着前一交易日就有头寸。该情况下，利润就是前一交易日的“有头寸”的利润
          - 因此对于任意交易日来说，当日有头寸和无头寸的利润就是：
            - 无头寸利润 = max(今日卖出后无头寸, 今日无交易也无头寸) = max(前一交易日有头寸+今日卖出价格, 前一交易日无头寸利润)
            - 有头寸利润 = max(今日买入后有头寸, 今日无交易但有头寸) = max(-1*今日买入价格, 前一交易日有头寸利润)
          - 令$h(n)$表示第n交易日有头寸利润，$g(n)$表示第n交易日无头寸利润，则n个交易日后的最大利润$f(n)$：

            $
            f(n) = max\left\{\begin{array}{l}
            h(n) = max(-Prices(n), h(n-1)) \\
            g(n) = max(h(n-1)+Prices(n), g(n-1))\\
            \end{array}\right.
            $

            其中，$h(1) = -Prices(1)$，$g(1) = 0$

        - 【TODO】
          - 从以上递推式可以看出，任意交易日的结果只取决于前一个交易日，可以简化记忆，每次计算时滚动更新两个变量来记录前一交易日的有头寸和无头寸利润即可

      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【贪心法】
      - 分析
        - 【TODO】
      - 步骤
        1. 设置两个变量，一个记录最低价格，一个记录最高利润
        1. 遍历数组的每个元素：
           1. 检查是否低于最低价格：
              - 是：更新最低价格
              - 否：与最低价格相减，检查差值是否高于最高利润：
                - 是：更新最高利润
                - 否：继续
        1. 返回最高利润
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [53.最大子序和](questions/wrong/53.最大子序和.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 数组中的最大子序列是以数组中的某两个小标分隔出来的连续序列，因为一般正向遍历，当遍历到子序列尾的时候就已经把整个子序列遍历完，所以以序列尾标作为锚，即定义$f(i)$为以第$i$个元素结尾的子序列和
      - 整个数组的最大子序和即为：$max\{f(i) | i \in [0,n) \}$
      - 对于任意的$f(i)$，其值取决于$f(i-1)$和第$i$个元素：
        $f(i) = max(f(i-1) + a_i, a_i)$
        - $f(i-1)$大于0时：以第i个元素为结尾的子序列和要取得最大值，必然包含以i-1为结尾的子序列
        - $f(i-1)$小于0时：以第i个元素为结尾的子序列和要取得最大值，必不能包含以i-1为结尾的子序列
    - 【TODO】
      - 任意$f(i)$的计算只取决于前一个$f(i-1)$，而最终结果以及每个$f(i)$是否有可能成为最大子序和都只取决于之前遍历到的最大的$f(i)$
      - 因此只需要两个变量即可简化记忆，一个记录前一个$f(i)$，一个记录之前遍历到的最大的$f(i)$，并在遍历过程中不断更新这两个记录值即可
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [198.打家劫舍](questions/optimizable/198.打家劫舍.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
          - 为了得到最大值，偷家序列中的“连续不偷子序列”不可能大于等于3，即不可能连续3家以上选择不偷
          - 因此对任一房屋i来说：
            - 选择偷：则i-2房屋也要一起偷，否则无法得到最大值
            - 选择不偷：则i-1的房屋必须偷，否则无法得到最大值
          - 所以任意房屋i的最大偷窃金额取决于前两个房屋：

            $f(i) = max\left\{\begin{array}{l}
            f(i-2) + a_i \\
            f(i-1)
            \end{array}\right.$

          - 则$f(n)$，即n个房屋的最大偷窃金额即最终结果
        - 【TODO】
          - 因为任意$f(i)$的计算只取决于前两个房屋，所以可以简化记忆为两个变量，分别记录前两个房屋，并在遍历过程中滚动更新即可
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [204.计数质数](questions/wrong/204.计数质数.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 质数的定义是因子只有1和自身，那么如果某数不是质数，则它必然可以因式分解为某几个质数，即它必然是某几个质数的倍数
      - 因此，只有知道某个数x是质数，则必然知道2x，3x等不是质数
      - 而对于某个数是否为质数，我们只能通过其有没有自身以外的质因子判断，而这些质因子若存在，则必然比他小
      - 这意味着我们可以从最小的已知质数开始计算每个质数的倍数并做标记，当遍历到某个更大的数时，该数若有标记就是合数，因为之前遍历发现了它的质因子；若无标记则是质数，因为它没有比它更小的质因子
  - 解法
    - 【埃氏筛】
      - 分析
        - 【TODO】
          - 对于遍历到的某个质数x，虽然他的倍数如2x，3x等必然是合数，但其中有部分倍数即$\{n \cdot x | n \in [0, x) \}$是已经被小于x的质数标记过的，不需要由质数x来冗余标记
          - 所以对任意质数x，他的倍数的计算可以直接从它的平方开始，即$x \cdot x$、$x(x+1)$
      - 步骤
        1. 构建长度为n的状态数组，小于n的所有数的状态都初始化为true，即先认为所有数都是质数
        1. 从2这个已知质数开始遍历小于n的所有数，令i为迭代变量：
           1. 检查状态数组中以i为下标的状态：
              - false：继续遍历
              - true：
                1. 累加质数数量
                1. 检查$i^2$是否小于n：
                   - 否：继续遍历
                   - 是：
                     1. 从$i^2$开始遍历，令j为迭代变量，每次迭代步长为i：
                        1. 将状态数组以j为下标的状态置为false
        1. 返回质数数量累加值
      - 复杂度
        - 时间：O($n\log_2\log_2n$)
        - 空间：O(n)
    - 【线性筛】
      - 分析
        - 【TODO】
          - 埃氏筛是有冗余标记的。任意合数有几个质因子就会被埃氏筛冗余标记几次，导致时间复杂度无法达到O(n)
          - TODO
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(n)
        - 空间：O(n)

- [326.3-的幂](questions/wrong/326.3-的幂.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 步骤
        1. 循环检查n是否大于0：
           - 是：检查n是否能整除3：
             - 是：计算n除以3地商，并将商结果覆盖n
             - 否：跳出循环
           - 否：跳出循环
        1. 返回n是否等于1的判定结果
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【TODO】
      - 分析
        - 【TODO】
          - 32位整数中最大的3的幂为$3^19$，只要n是$3^19$的约数，那么n就必定是3的幂，否则就必定不是3的幂
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [191.位-1-的个数](questions/optimizable/191.位-1-的个数.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
          - 对于一个比较短的位串，我们是可以直接看出有几个1的。即一个比较小的k，k-位串中1的数量可以直接看出来。则一个较大的位串可以分成好几个小段，直接累加每段中1的数量
          - 那么我们可以构建一个k-位串表，以k-位串所有可能值作为下标或者说映射的键，则表上有$2^k$个元素，每个元素值都是其下标的二进制表示中1的数量
          - n每次都与全是1的k-位串做位与运算，可以得到最低k位的二进制表示，该位串作为下标直接查表即可得到n最低k位中有几个1，统计后将n向右位移即可继续做同样的运算
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【Brian Kernighan】
      - 分析
        - 【TODO】
          - 只要不断右移并统计最低位的1的个数，或者用$2^i$来匹配并统计即可
          - 但是注意$n \& (n-1)$的运算结果恰好就是把n最低为的1置0，可以利用该性质加速检查过程
          - 不断将$n \& (n-1)$的运算结果覆盖n，直到n=0，期间计算了多少次，n中就有多少个1
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【平行法】
      - 分析
        - 【TODO】
          - 将位串每相邻的两位分成一组，每组的两位相加并将运算结果的二进制表示覆盖本组，此时每组的两个位合起来表示的是本组的1的数量
          - 将整个位串每相邻的四位分成一组，每组的四位相加并将运算结果的二进制表示覆盖本组，此时每组的四个位合起来表示的是本组的1的数量
          - 不断扩大每组的位数并重复上述步骤，直到所有位分作一组并计算出相加结果即可得到整个位串的1的数量
      - 算法

        ```rust
        fn hamming_weight(mut n: u32) -> usize {
            n = ((n & 0xaaaaaaaa) >> 1) + (n & 0x55555555);
            n = ((n & 0xcccccccc) >> 2) + (n & 0x33333333);
            n = ((n & 0xf0f0f0f0) >> 4) + (n & 0x0f0f0f0f);
            n = ((n & 0xff00ff00) >> 8) + (n & 0x00ff00ff);
            n = ((n & 0xffff0000) >> 16) + (n & 0x0000ffff);
            n as usize
        }
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [461.汉明距离](questions/accepted/461.汉明距离.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 异或运算识别出两个位串有哪些位不同，这些位都会被置为1
      - 计算异或结果中1的个数即可得到汉明距离
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [190.颠倒二进制位](questions/wrong/190.颠倒二进制位.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【二分旋转】
      - 分析
        - 【TODO】
          - 将32位串分成两半进行旋转，即前16位和后16位整体交换
          - 再分别对两串16位串分成两半8位串继续旋转
          - 以此类推直到分割成两个1位串并旋转完
      - 算法

        ```rust
        fn reverse_bits(mut x: u32) -> usize {
            x = (x >> 16) | (x << 16);
            x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8);
            x = ((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4);
            x = ((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2);
            x = ((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1);
            x as usize
        }
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

    - 【分治】
      - 分析
        - 【TODO】
          - 将位串每相邻的两位分成一组，每组的两位交换
          - 再将整个位串每相邻的四位分成一组，每组的高两位和低两位整体交换
          - 如上不断扩大每组的位数并重复上述步骤，直到所有位分作一组并把高16位和低16位整体交换
      - 算法

        ```rust
        fn reverse_bits(mut x: u32) -> usize {
            x = ((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1);
            x = ((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2);
            x = ((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4);
            x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8);
            x = ((x & 0xffff0000) >> 16) | ((x & 0x0000ffff) << 16);
            x as usize
        }
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [118.杨辉三角](questions/accepted/118.杨辉三角.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 杨辉三角在计算机的按行存储的模型下，会被左对齐，三角左边的1在一列上
      - 在计算机存储模型视角下，杨辉三角每个元素(i,j)都是上一行的同列元素(i-1, j)和前列元素(i-1, j-1)之和
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [20.有效的括号](questions/accepted/20.有效的括号.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 一个有效的括号表达式，最底层的嵌套的括号对，其开括号一定比上层开括号出现的最晚，但其闭括号却比上层闭括号出现的最早，这很适合栈的出入原则——后进先出
      - 遇到开括号入栈，遇到闭括号，就出栈检查开括号是否与该闭括号匹配
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [268.丢失的数字](questions/wrong/268.丢失的数字.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 数组有n个数，每个数都不同，而值域是[0, n]的n+1个数，意味着数组只缺失了一个数字
  - 解法
    - 【TODO】
      - 分析
        - 【数学：数列求和】
          - 这是一个缺失了一个数字的等差数列，可以计算该等差数列和，然后再计算数组和，两个和相减的差就是缺失的数字
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【TODO】
      - 分析
        - 【数学：异或位运算】
          - 数组的每个数字都是唯一的，而且只缺失了值域中的一个数字，意味着如果在数组后面把值域所有数字都添加上去，则缺失的数字唯一，而其他数字全都重复两次
          - 对于一个数组只有一个数字唯一，其他数字都重复两次，可以使用异或位运算的性质求解
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [15.三数之和](questions/wrong/15.三数之和.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 蛮力法通过枚举所有可能的三元组来解题，每一次枚举都首先遍历地确定第一个元素和第二个元素，然后遍历寻找第三个元素。遍历完后枚举一个新的第二元素，再进行一次第三元素的枚举。第二元素也遍历完了就开始枚举新的第一元素，直到所有元素曾作为第一元素被枚举过
      - 分析$a_i + a_j + a_k = 0$，可以发现：
        - 要么三个元素全是0，否则必有一个元素是小于0的，且还元素肯定是元组最小值，我们让最小值总是排在三元组第一位。这意味着如果我们可以在遍历第一元素时**确定之后元素都是正数**的话，就可以提前结束枚举。如果将数组排序，即可很快确定正负元素分界，从而实现优化
        - 当第一元$a_i$确定后，我们就是要寻找一个$(j, k)$组合使得$a_j + a_k = -a_i$。我们可以假设不等式$a_j \leq a_k$成立，这意味着当我们遍历时有以下三种情况：
          - $a_j + a_k < -a_i$：如果我们**令第三元总是当前剩余元素里最大的那个**元素，则这种情况意味着**第二元素$a_j$太小**了，我们需要稍微大一点的第三元。如果将数组排序，即可很快找到更大的元素
          - $a_j + a_k > -a_i$：如果我们**令第二元总是当前剩余元素里最小的那个**元素，则这种情况意味着**第三元素$a_k$太大**了，我们需要稍微小一点的第三元。如果将数组排序，即可很快找到更小的元素
          - $a_j + a_k = -a_i$：找到一个符合要求的元组，将$a_j$和$a_k$都从备选元素里排除，因为他们任何一个都不可能再和当前的第一元$a_i$组成一个不重复的三元组了
      - 从以上分析可见，将数组排序可以得到较大的优化，且排序后去重也变得简单，只要遍历时简单跳过重复元素即可，对于排序后的数组：
        - 三元组所有元遍历时都跳过和上一次遍历元素重复的元素
        - 第一元遍历到非0正数就停止遍历返回结果
        - 第二元从第一元的下一元素开始遍历，第三元则从数组末尾开始遍历。重复迭代到二者交叉后迭代第一元：
          - 二者和太小：第二元向前迭代一步
          - 二者和太大：第三元向前迭代一步
          - 找到符合条件三元组：第二元和第三元同时向前迭代一步
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O($n^2$)
        - 空间：O($log_2n$)

- [73.矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)（[我的实现](questions/wrong/73.矩阵置零.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 在矩阵中遇到一个0元素时，不能直接将所在行列元素清0，否则接下来的遍历中遇到的0很难确认是原本为0还是被清理成0，从而无法确定是否要执行行列的清0操作。因此遇到0元素，没有辅助空间标记要被清0的行列，将会非常困难
      - 但如果限制不使用额外空间，就必然要从数据本身自带的空间“原地”标记，需要两块空间分别标记行列，而矩阵**首行标记列**和**首列标记行**是个容易想到的选择
      - 首行和首列的内容会在遍历矩阵过程中被修改，但是这样的修改是不影响输出正确性的，因为首行和首列无论本身就是0还是被清0，其最终结果也都是0
      - 首行和首列记录了矩阵其余行列是否应该被清0，但无法记录矩阵的首行首列是否应该被清0，所以需要两个额外的变量标记
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [49.字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/solution/)（[我的实现](questions/wrong/49.字母异位词分组.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 字母异位词的长度一致，用到的字母一致，包括某个字母重复次数也一致
  - 解法
    - 【排序+哈希】
      - 分析
        - 【TODO】
          - 字母异位词意味着它们排序后完全相同，因此可以每个词排序后的值作为映射的键，将异位词数组作为映射的值
      - 算法

        ```TODO
        ```

      - 复杂度：n是输入字符串数量，k是输入字符串中最长的串的长度
        - 时间：O($nklog_2k$)
        - 空间：O($nk$)

    - 【计数+哈希】
      - 分析
        - 【TODO】
          - 字母异位词意味着每个字母的出现次数是一样的，可以用一个长度等于字母表长度的辅助空间记录每个词的每个字母出现次数，并以每字母出现次数为映射的键，将异位词数组作为映射的值
      - 算法

        ```TODO
        ```

      - 复杂度：n是输入字符串数量，k是输入字符串中最长的串的长度，$\Sigma$是字母表长度
        - 时间：O($n(k+\Sigma)$)
        - 空间：O($n(k+\Sigma)$)

- [3.无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)（[我的实现](questions/accepted/3.无重复字符的最长子串.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 遍历字符串时，如何判断当前字符是不是重复字符，如何判断遇到重复字符时如何操作最省时间，这些问题可以借鉴KMP回溯的思想：
        - 可以通过哈希的方法判断遍历到的字符是不是重复字符
        - 遇到重复字符时就要滑动子串的开头，让它去掉子串头到重复字符在内的所有字符
      - 综上可以通过以字符值为键，字符下标为值的哈希表，每当遍历到在哈希表有记录的字符就是遇到重复字符，把子串头设置为哈希表记录的下标的下一位，并将当前遍历到的字符下标更新到哈希表
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [5.最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)（[我的实现](questions/wrong/5.最长回文子串.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【动态规划】
      - 分析
        - 【TODO】
          - 回文串去掉头尾之后依旧是回文串，换言之，一个串是不是回文串取决于头尾是否相等以及去掉头尾后是不是回文串
          - 因此一个串是不是回文取决于一个更小规模的子问题的解，即可以分解为子问题
          - 综上，令$P(i,j)$表达串从i到j的子串是否为回文，$s_i$表达串的第i个字符，则转移方程为：

            $
            P(i, j) = P(i+1, j-1) \wedge (s_i == s_j)
            $

            边界条件为：

            $
            \left\{\begin{array}{l}
            P(i, i) = true \\
            P(i, i+1) = s_i == s_{i+1} \\
            \end{array}\right.
            $

          - 实现时为了避免重复计算，可以从最短长度即长度为1开始枚举回文子串，每次枚举都从首个字符开始遍历，检查以该字符开始的有指定长度的子串是否是回文

      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

    - 【TODO】
      - 分析
        - 可以从两个角度来分析：
          - 【TODO】从直觉角度来分析：
            - 回文串都有回文中心并从回文中心向两边对称扩展
            - 因此可以遍历串的每个字符，以每个字符为回文中心检查可以对称扩展多远
            - 注意长度奇偶不同的回文串的中心不同
          - 【TODO】从优化动态规划算法来分析：
            - 分析动态规划方法的转移方程，其状态转移链是这样的：

              $P(i,j) \leftarrow P(i+1,j-1) \leftarrow P(i+2,j-2) \leftarrow ... \leftarrow 边界情况$

              即状态转移链是单分支的，即任意状态的转移都是确定的，只有一个转移方向

            - 因此我们可以从每一种边界开始扩展到该边界能够扩展到的最终状态，这样一种边界能够扩展到的最终状态和中间状态都会被遍历计算到，当把所有可能的边界遍历完，则所有状态都被枚举并计算，也就完成了动态规划的全部计算
            - 而边界情况就是所有的单个字符或双字符，扩展方法就是以单字符或双字符为回文中心向两边检查是否对称
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

    - 【Manacher（马拉车）】
      - 分析
        - 【TODO】
          - 就像KMP回溯算法的基本思想一样，当我们遍历某个字符作为回文中心的时候，我们对它其实并非一无所知，我们可以从之前遍历到的字符中得到关于它的信息
          - “回文臂”是回文中心到回文串头或尾的半径，则奇数回文串的长度是两倍臂长加一，偶数回文串是两倍臂长。请注意右侧回文臂内的每个字符在左侧回文臂内都有对应相等的字符，且这两个字符左右两侧紧邻的部分字符也是相等的。所以当我们从右侧回文臂选择任一个符作为回文中心时，都可以从左侧回文臂内我们曾遍历过的字符中获取历史信息
          - 具体来说就是当我们把某个字符$s_j$作为回文中心并发现回文串后，枚举回文臂内任一字符$s_i$作为回文中心时，都可以复用另一侧回文臂对应的字符$s_{2j-i}$被作为回文中心遍历时的信息即以$s_{2j-i}$为回文中心的回文臂长$L_{2j-i}$
          - 因为回文串的对称性，以$s_i$作为回文中心时，可以直接跳过两侧$L_{2j-i}$个字符，直接从$(i-L_{2j-i}-1, i+L_{2j-i}+1)$的对子开始比对。但要注意的是我们的已知信息来源于以$s_j$为中心的回文串，因此已知范围在回文臂范围内，而$s_{2j-i}$为中心的回文串是有可能有部分串不在$s_j$回文串内的，所以在计算可以跳过的字符数量时要做限制：$min(L_{2j-i}, j+L_{j}-i)$
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [334.递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence/)（[我的实现](questions/wrong/334.递增的三元子序列.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 一个递增的三元序列，其前两元组成的序列必然是递增二元序列，也就是说递增三元子序列存在的必要条件是存在递增二元子序列
      - 递增二元子序列的寻找和确定是简单的，而且总能找到出现的第一个递增二元子序列。当找到第一个递增二元子序列$\left<s_i, s_j\right>$后，接下来寻找第三元$s_k$时，遍历到的元素$A$会有以下三种情况：
        - $s_i < s_j < A$：A就是我们要找的第三元，直接返回结果
        - $s_i < A < s_j$：A到现在的第二元之间没有我们要找的第三元，而A比当前的第二元小，又是位于第一元之后的比第一元大的元素，将第二元更新为A，显然放宽了第三元的条件，能在之后更容易找到符合要求的第三元
        - $A < s_i < s_j$：
          - 因为只要A的值比第二元大，就可以确定A是第三元，而第一元的值是用不上的，换言之，在这个递增的场景下，第二元的值是包含了第一元的值的信息的（即“前面有更小的元素”这一信息），这一隐含的约束确保递增三元序列的成立
          - 既然第一元的值用不上，那么更新第一元为更小的元素值，显然是放宽了第二元的条件，能在之后寻找到更小的第二元，从而放宽第三元的条件
          - 但是不能滚动地把第一元的旧值更新给第二元，尽管这看起来非常自然。因为第一元的值并不必然包含“前面有更小的元素”这一条件，破坏了我们找到的第一次出现的递增二元子序列里第二元包含的逻辑约束，使得之后再找到比使用第一元值的第二元更大的元素时，无法确保是有一个递增三元子序列存在
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [160.相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)（[我的实现](questions/wrong/160.相交链表.c)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
          - 因为两个链不一定长度相同，使得遍历时不能保证同时迭代到相交节点，导致无法通过比对指针来确定是否共链
          - 可以先确定两个链表长度，计算长度差，让较长的链表先行迭代到长度差被抹平，再两个链表同时迭代，就能保证相交节点可以被同时遍历到
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(n)
        - 空间：O(1)
    - 【TODO】
      - 分析
        - 【TODO】
          - 两个指针分别对两个链表同时遍历，一旦指针所在链表遍历完后就立刻从另一个链表头开始继续遍历，直到两个指针相遇，此时相遇节点就是相交点
          - 这个算法我不知道是怎么想出来发明出来的，但是其正确性是可以简单证明的：
            - 两个链表分别是：
              - $a_1 \rightarrow a_2 \rightarrow c_1 \rightarrow c_2 \rightarrow c_3$
              - $b_1 \rightarrow b_2 \rightarrow b_3 \rightarrow c_1 \rightarrow c_2 \rightarrow c_3$
            - 该算法下两个指针的遍历路径如下：
              - $a_1, a_2, c_1, c_2, c_3, b_1, b_2, b_3, c_1$
              - $b_1, b_2, b_3, c_1, c_2, c_3, a_1, a_2, c_1$
            - 显然无论链表如何变化，都会如同以上遍历路径，最终只需要$2n+2m+k+1$步即可相遇，其中n和m是链表各自不相交的节点数，k是相交共享的节点数
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [103.二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)（[我的实现](questions/optimizable/103.二叉树的锯齿形层序遍历.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 因为输出结果要求按层序组织，所以层序遍历时稍微修改一下，每次出队都把整队列所有节点出队即可实现按层序处理该层所有节点，从而实现结果按层序组织
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [105.从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)（[我的实现](questions/wrong/105.从前序与中序遍历序列构造二叉树.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
          - 前序遍历和中序遍历的输出结果分别如下：
            - 前序：{ 根, {左子树}, {右子树} }
            - 中序：{ {左子树}, 根, {右子树} }
          - 可根据前序的第一个元素确定中序哪个元素是根
          - 中序确定根后，可知左子树和右子树分别有多少个节点，从而在前序中划分出左右子树
          - 递归运用以上两点性质即可通过前序和中序来反序列化二叉树
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【TODO】
      - 分析
        - 【TODO】
          - 从任意子树根到该子树的最左叶子的节点，把这些节点从前序遍历或者中序遍历中保持出现顺序地摘选出来，一个称为**前序摘选**，一个称为**中序摘选**，而该子树则称为**摘选子树**，则有如下性质：
            - **前序摘选性质**：
              1. 前序摘选的首个元素总会是被摘选子树的根
              1. 前序摘选在前序遍历中总是一个紧邻相连的部分，即被摘选的节点之间没有其他节点穿插其中
              1. 前序摘选最后一个被摘选节点，在前序遍历中该节点后面紧邻的节点必定是被摘选节点中某一节点的右子树根
              1. 前序摘选的左边界即首元素，是摘选迭代中确定的，一开始是前序遍历结果的首元素作为左边界，之后是上一摘选子树右边界节点在前序遍历中紧随其后的节点
            - **中序摘选性质**：
              1. 中序摘选的首个元素总会是被摘选子树的最左叶子
              1. 中序摘选在中序遍历中是否是紧邻相连的部分，取决于这些节点有无右子树：
                 1. 所有节点没有右子树：中序摘选也是中序遍历中一块紧邻相连的部分
                 1. 至少一个节点有右子树：中序遍历中这些被摘选的节点不是紧邻相连的，其中必有某两个被摘选节点之间穿插了前一个节点的右子树
              1. 中序摘选的左边界即首元素，是摘选迭代中确定的，一开始是中序遍历结果的首元素作为左边界，之后是上一摘选子树中第一个在中序遍历被穿插分隔的摘选节点的紧随其后的节点
          - 前序摘选和中序摘选之间有如下**关系**：
            1. 前序摘选总是会与中序摘选相反，即互为逆序
            1. 根据中序摘选的**性质2**，可以确定前序摘选的右边界节点
            1. 根据前序摘选的**性质2**，可以确定中序摘选的右边界节点
            1. 根据中序摘选的**性质3.2**，可以确定前序摘选中哪一个节点拥有**性质3**提到的右子树
          - 实现方法大致如下：
            1. 设置一个变量作为当前摘选子树最左叶子的锚，也就是中序摘选左边界。初值是指向中序遍历首元素，即整棵树的最左叶子
            1. 遍历前序结果并逐个按序压栈，直到栈顶节点等于最左锚。此时栈中就是当前摘选子树的前序摘选，而当前遍历到但尚未压栈的前序结果节点就是新摘选子树根
            1. 接下来我们要做的就是为新摘选子树找到其父节点是当前哪一个摘选节点，根据**关系4**：

               注意，最左锚指向中序遍历中被摘选子树所在的区间内，要么指向摘选节点，要么指向某个摘选节点的右子树

               1. 检查栈顶节点是否等于最左锚：
                  - 等于：出栈，同时向右推动最左锚
                    - 二者相等意味着目前前序摘选的逆序（入栈会反序化）和中序摘选的逆序是这一部分是相等，这表明现在遍历到的摘选节点都是无右子树节点，新摘选子树的父节点还没有找到
                    - 出栈并向右推动最左锚相当于同时遍历前序摘选的逆序和中序摘选
                  - 不等：跳出寻找新摘选子树的父节点的循环，以新摘选子树继续之前的循环，此时最左锚就是新摘选子树的最左锚
            1. 上述不断摘选的过程就是还原了正确的前序遍历过程，只要在过程中适当地方建立二叉树关系即可
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [116.填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)（[我的实现](questions/wrong/116.填充每个节点的下一个右侧节点指针.c)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
          - 如果可以按顺序的分层遍历每层的节点，就可以简单的设置next指针，而层序遍历就能做到
          - 需要注意的是，因为每层的最后一个节点的next指针是空而不是指向下一层，所以结果是按层组织的，层序遍历时要一次把整层都倒出来遍历，不能一边遍历一边插队
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【TODO】
      - 分析
        - 【TODO】
          - 树的遍历总是要用到额外空间的，但如果限制为O(1)空间的话，就必然要利用甚至占用输入数据内的空间
          - 对于任一节点来说，如果它是父节点的：
            - 左子节点：则该节点的next指向兄弟节点即父节点的右子节点
            - 右子节点：则该节点的next指向父节点的next节点的左子节点
          - 也就是说对于任一层节点来说，只要上一层节点的next被正确设置，就能简单遍历上一层节点来设置其下一层节点的next
          - 而整棵树的第一层是根节点，也恰好是next被正确设置的一层，从第一层开始可以递推地设置完所有层
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [230.二叉搜索树中第k小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)（[我的实现](questions/wrong/230.二叉搜索树中第k小的元素.rs)）
  - 条件
    - 【二叉搜索树】
  - 分析
    - 【TODO】
      - 二叉搜索树的中序遍历是一个有序的序列
      - 只需要中序遍历该树，返回遍历到的第k个节点即可
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [75.颜色分类](https://leetcode-cn.com/problems/sort-colors/)（[我的实现](questions/accepted/75.颜色分类.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 借鉴快排的“维护有序区间”的思想，开辟至少两个有序区间并不断扩展维护，直到两个有序区间扩展到极限，将所有属于该区间的元素都吸纳进来后，剩下的那个原本无序的区间也会变成有序区间
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
          - 在数组的头部开辟两个向尾部扩展的有序区间，一个是纯0区间，一个是纯1区间，遍历到0就和0区间尾交换，遍历到1就和1区间尾交换，交换后遍历迭代到下一步
          - 需要注意的是，1区间是堆叠在0区间后面的，因此当1区间非空时，扩展0区间会把1区间的元素交换出来。为了避免这个问题，当1区间非空时，交换0元素后，还要把交换出来的1再跟1区间尾元素交换
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【TODO】
      - 分析
        - 【TODO】
          - 在数组的头部开辟向尾部扩展的纯0区间，在数组尾部开辟向头部扩展纯2区间，遍历到0就和0区间尾交换，遍历到2就和2区间尾交换，交换后遍历迭代到下一步
          - 令$p_0$代表0区间尾，$p_2$代表2区间尾，$i$代表遍历指针，则：
            - $p_0 \leq i \leq p_2$必然成立
            - 对于$a_i$的值：
              - $a_i = 0$
                - $i = p_0$：遍历元素紧邻0区间，发现的0就在0区间下一次扩展要使用的空间中，此时交换相当于直接扩展0区间
                - $i > p_0$：遍历元素和0区间之间穿插了许多1，此时交换相当于把紧邻0区间、占用了0区间下一次扩展空间的1和遍历发现的0交换
              - $a_i = 2$

                2区间不像0区间那样隐含了约束“遍历元素与0区间之间只有1（纯1有序区间）”，因此遍历元素可能与紧邻2区间的非1元素（$a_{p2-1}=0或2$）进行了交换

                - $a_{p2-1} = 2$：此时需要不断循环遍历元素并同时扩展2区间直到遍历到非2元素（0或1）。需要注意的是，遇到0元素还要将其添加到0区间
                - $a_{p2-1} = 0$：此时不能直接遍历下一个元素，需要将0元素添加到0区间
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [347.前-k-个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)（[我的实现](questions/wrong/347.前-k-个高频元素.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【k-堆】
      - 分析
        - 【TODO】
          - 维护一个只有k个元素的最小堆，将统计出来的元素出现次数放入堆中：
            - 堆节点小于k个：直接入堆
            - 堆节点等于k个：比较堆顶和当前遍历的元素出现次数：
              - 堆顶更大：跳过当前遍历的元素出现次数
              - 堆顶更小：取出堆顶后入堆。因为当前遍历的元素出现次数比堆顶元素更多，更有资格进入top-K
          - 遍历结束后，堆就是要找的前k个元素
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

    - 【快速选择】
      - 分析
        - 【TODO】
          - 统计元素出现次数组成次数数组后，除了直接排序来确定前k元外，可以借鉴快排的思想
          - 借鉴快排的维护有序区间的思想，每次选择一个元素作为有序区间的守卫元，开辟并一个比守卫元小的有序区间，然后比较有序区间的长度$l$和$k$：
            - $l=k$：找到了top-K，返回结果
            - $l<k$：在守卫元的右侧有序区间中选择一个新的守卫元，并仅对该区间数据再进行一次类似快排的步骤
            - $l>k$：在守卫元的左侧有序区间中选择一个新的守卫元，并仅对该区间数据再进行一次类似快排的步骤
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [215.数组中的第k个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)（[我的实现](questions/wrong/215.数组中的第k个最大元素.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【k-堆】
      - 分析
        - 【TODO】
          - 维护一个只有k个元素的最小堆，遍历输入元素依次放入堆中：
            - 堆节点小于k个：直接入堆
            - 堆节点等于k个：比较堆顶和当前遍历的元素：
              - 堆顶更大：跳过当前遍历的元素出现次数
              - 堆顶更小：取出堆顶后入堆。因为当前遍历的元素比堆顶元素更大，更有资格进入top-K
          - 遍历结束后，堆顶就是要找的第k个最大元素
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

    - 【快速选择】
      - 分析
        - 【TODO】
          - 可以借鉴快排的维护有序区间的思想，每次选择一个元素作为有序区间的守卫元，开辟并一个比守卫元小的有序区间，然后比较有序区间的长度$l$和$k$：
            - $l=k$：找到了top-K，返回结果
            - $l<k$：在守卫元的右侧有序区间中选择一个新的守卫元，并仅对该区间数据再进行一次类似快排的步骤
            - $l>k$：在守卫元的左侧有序区间中选择一个新的守卫元，并仅对该区间数据再进行一次类似快排的步骤
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [162.寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)（[我的实现](questions/wrong/162.寻找峰值.rs)）
  - 条件
    - 【TODO】数组两侧视为无穷小：$a_{-1} = a_n = -\infty$
    - 【TODO】数组任意一对相邻的两个数不相等：$a_{i-1} \ne a_i \ne a_{i+1}$
  - 分析
    - 【TODO】
      - 有三种情况下的数组不存在峰值，但这三种情况都因题目条件限制而不可能成立：
        - 单调递增：数组尾元素满足峰值条件：
          - 大于前一元素：因为严格单调递增，尾元素是最大值，必然大于前一元素
          - 大于后一元素（数组尾）：因为数组尾是负无穷，意味着尾元素大于数组尾
        - 单调递减：数组首元素满足峰值条件：
          - 大于前一元素（数组头）：因为数组头是负无穷，意味着首元素大于数组头
          - 大于后一元素：因为严格单调递减，首元素是最大值，必然大于后一元素
        - 不增不减：因为限制了相邻两个元素不等，所以数组所有元素相等是不可能成立的
      - 综上，数组峰值必定存在，且按单调性分割数组，可以不遗漏任何元素地分成多个单调数列
      - 将数组按单调性划分为多个单调数列后，峰值只存在于以下两种情况：
        - 递增数列尾：
          - 数列尾是数组尾元素：如上分析，此时数列尾是峰值
          - 数列尾不是数组尾元素：
            - 大于前一元素：因为严格单调递增，尾元素是最大值，必然大于前一元素
            - 大于后一元素：后一元素必然小于数列尾，否则递增数列应扩展数列尾到后一元素
        - 递减数列头：
          - 数列头是数组首元素：如上分析，此时数列头是峰值
          - 数列头不是数组首元素：
            - 大于前一元素：前一元素必然小于数列头，否则递减数列应扩展数列头到前一元素
            - 大于后一元素：因为严格单调递减，首元素是最大值，必然大于后一元素
      - 单调数列划分后，任一元素必然属于其中一个单调数列，有以下三种情况：
        - 递增数列尾+递减数列头：此时元素站在相邻的递增数列和递减数列之间，恰好就是峰值
        - 递增数列元素：此时元素属于递增数列，峰值在它的右侧沿着数字增大的方向
        - 递减数列元素：此时元素属于递减数列，峰值在它的左侧沿着数字增大的方向
      - 综上，对于任意元素而言，要么是峰值，要么沿着左右两侧数字增大的方向遍历可以找到峰值
  - 解法
    - 【二分查找】
      - 分析
        - 【TODO】
          - 因为非峰值元素只要沿着左右两侧数字增大的方向就可以找到峰值，我们可以依据这个定义二分搜索规则：对于每次二分出来的中间元素：
            - 中间元素大于两侧：找到峰值，返回结果
            - 中间元素小于两侧：此时向任一侧继续二分都可以，我们规定向右侧
            - 中间元素仅小于左侧：向左侧继续二分查找
            - 中间元素仅小于右侧：向右侧继续二分查找
          - 使用以上二分规则就可以实现二分查找来找到峰值
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [33.搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)（[我的实现](questions/wrong/33.搜索旋转排序数组.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 虽然我们不知道旋转后两个子数组的交界在哪儿，但被旋转的数组是升序排列的，意味着两个子数组较大的那个一定在数组前半部分，较小的一定在数组后半部分
      - 这意味着数组首元素就是左子数组的首元素，即数组首元素$a_0$一定是大于右子数组的所有元素的，因此可通过判断任一元素与数组首元素的大小关系来确定该元素应该会在左右哪一数组中出现
      - 具体来说，对任意的目标元素$t$，有如下情况：
        - $t = a_0$：数组首元就是目标元素，直接返回结果
        - $t > a_0$：目标元素必然在左子数组。因为目标大于首元，所以一定大于整个右子数组，不可能等于其中某元素
        - $t < a_0$：目标元素必然在右子数组。因为目标小于首元，所以一定小于整个左子数组，不可能等于其中某元素
      - 对于除$t$以外的另一个元素$a_m$，该元素要么大于它、要么小于它，综合$t$和$a_m$分别在左右哪个数组来考虑有：
        - $t > a_0$（$t$在左数组）：
          - $a_m > a_0$（$a_m$在左数组）：
            - $a_m < t$：$a_m$的右侧是$t$
            - $a_m > t$：$a_m$的左侧是$t$
          - $a_m < a_0$（$a_m$在右数组）：$a_m$的左侧是$t$
        - $t < a_0$（$t$在右数组）：
          - $a_m > a_0$（$a_m$在左数组）：$a_m$的右侧是$t$
          - $a_m < a_0$（$a_m$在右数组）：
            - $a_m < t$：$a_m$的右侧是$t$
            - $a_m > t$：$a_m$的左侧是$t$
      - 以上关系性质定义了任意元素如何确定向哪个方向迭代能接近目标元素的规则，可以直接用于定义二分搜索规则，从而实现二分搜索查找目标元素
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [240.搜索二维矩阵-ii](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)（[我的实现](questions/wrong/240.搜索二维矩阵-ii.rs)）
  - 条件
    - 【矩阵】
    - 【有序】每行按升序排列，每列也按升序排列
  - 分析
    - 【TODO】
      - 矩阵中的行列都是升序排列，这意味着对任一元素$a_{xy}$，比对其与目标$t$大小关系时，有如下性质：
        - $t = a_{xy}$：该元素就是目标，返回结果
        - $t < a_{xy}$：因为列是升序排列，所以第y列从第x个元素以下都大于目标，因此不可能有目标值
        - $t > a_{xy}$：因为行是升序排列，所以第x行从第y个元素以前都小于目标，因此不可能有目标值
      - 综上，每次比对，我们要么找到目标、要么排除一列的部分元素，要么排除一行的部分元素。为了能排除更多的元素：
        - 从列头$a_{0y}$开始比对，因为发现目标小于元素时，该元素越靠近列头，就可以排除更多该列元素
        - 从行尾$a_{xn}$开始比对，因为发现目标大于元素时，该元素越靠近行尾，就可以排除更多该行元素
      - 因此我们可以从右上角的$a_{0n}$开始，向左下角的$a_{m0}$以Z形遍历比对，即从第一行开始每次遍历一行，每行从行尾开始遍历，令$i$位遍历行，$j$为遍历列：
        - $t = a_{ij}$：该元素就是目标，返回结果
        - $t < a_{ij}$：$j$向左前进一步

          整列排除，因为该列前i个元素已经在之前的遍历中被比对过，都不是目标，而剩下的$m-i$个元素都比目标大，不可能是目标

        - $t > a_{ij}$：$i$向下前进一步

          整列排除，因为该行后$n-j$个元素已经在之前的遍历中被比对过，都不是目标，而剩下的$j$个元素都比目标大，不可能是目标
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [34.在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)（[我的实现](questions/wrong/34.在排序数组中查找元素的第一个和最后一个位置.rs)）
  - 条件
    - 【数组】
    - 【有序】
  - 分析
    - 【TODO】
      - 有序数组中查找，可以使用二分查找的办法，但要对中值等于目标值的情况做不同处理：
        - $A_{mid} == T$：
          - 最先出现位置：**向右**移动。该情况意味着目标值最先出现的位置不可能在中值的右侧（因为右侧的值比中值出现的还晚），所以只可能是中值或者在中值左侧（因为左侧的值比中值出现的更早），因此和中值大于目标值的情况一样向右移动
          - 最后出现位置：**向左**移动。该情况意味着目标值最后出现的位置不可能在中值的左侧（因为左侧的值比中值出现的还早），所以只可能是中值或者在中值右侧（因为右侧的值比中值出现的更晚），因此和中值小于目标值的情况一样向左移动
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

## 二分查找

二分查找算法正确性证明如下：

循环不变式：目标值$T$如果存在与数组$A$中，则必然存在于区域$A[l .. r]$内

- 初始化：初始时$l=0$，$r=len(A)$，计算区域覆盖整个数组，此时循环不变式必然是成立的
- 保持：循环时，有如下操作，循环不变式依然成立：
  - $A_{mid} = T$：找到目标值，直接返回结果
  - $A_{mid} < T$：目标值不可能在中值左侧区域$[l .. mid]$内，只可能在右侧区域$[mid+1 .. r]$内，令$l = mid+1$。循环不变式依旧成立
  - $A_{mid} > T$：目标值不可能在中值右侧区域$[mid .. r]$内，只可能在左侧区域$[l .. mid-1]$内，令$r = mid-1$。循环不变式依旧成立
- 终止：$l > r$时停机，目标值不在数组内

### 二分查找最先出现

二分查找的变体，结合查找目的，每次二分查找时的三种情况中，等于目标值的情况有所不同：

- $A_{mid} = T$：找到目标值，则目标值首次出现的位置不可能在中值右侧区域$[mid .. r]$内，只可能在当前的中值位置，或者，左侧区域$[l .. mid-1]$内，因此令$r = mid-1$

即遇到等于目标值的元素也要像大于目标值那样，向左移动：

- $A_{mid} < T$：右移，令$l = mid+1$
- $A_{mid} \ge T$：左移，令$r = mid-1$

这个算法的正确性证明：

循环不变式：目标值$T$如果存在与数组$A$中，则目标值第一次出现的位置要么被记录为$I$，要么存在于区域$A[l .. r]$内

- 初始化：初始时$l=0$，$r=len(A)$，计算区域覆盖整个数组，此时循环不变式必然是成立的
- 保持：循环时，有如下操作，循环不变式依然成立：
  - $A_{mid} = T$：找到目标值，则目标值首次出现的位置不可能在中值右侧区域$[mid .. r]$内，只可能在当前的中值位置，或者，左侧区域$[l .. mid-1]$内，因此令$I = mid$，令$r = mid-1$。循环不变式依旧成立
  - $A_{mid} < T$：目标值首次出现的位置不可能在中值左侧区域$[l .. mid]$内，只可能在右侧区域$[mid+1 .. r]$内，令$l = mid+1$。循环不变式依旧成立
  - $A_{mid} > T$：目标值首次出现的位置不可能在中值右侧区域$[mid .. r]$内，只可能在左侧区域$[l .. mid-1]$内，令$r = mid-1$。循环不变式依旧成立
- 终止：$l > r$时停机：
  - $I$没有赋值：目标值不在数组内
  - $I$有赋值：$I$就是目标值首次出现位置

- [55.跳跃游戏](https://leetcode-cn.com/problems/jump-game/)（[我的实现](questions/wrong/55.跳跃游戏.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【动态规划】
      - 分析
        - 【TODO】
          - 当跳跃可以越过某个下标时，此时跳跃策略只有两种选择：
            - 直接越过该下标
            - 在该下标重新跳跃

            只有从该下标重新跳跃所能到达距离比直接越过还要短时，我们才会选择直接越过该下标，对于越过下标这个跳跃策略而言：

            - 从前一下标$i-1$越过当前下标$i$：前一下标$i-1$的最远距离等于下标对应值
            - 从比$i-1$更早的下标越过当前下标$i$：前一下标$i-1$的最远距离等于更前的下标$i-2, i-3, ...$等的最远距离，此时$i-1$的最远距离意味着$i-1$之前的某个下标起跳到达的最远距离

            当下标$i$选择被越过时，也意味着它之前的所有下标都可达，且从他之前的某个下标起跳可以比从它自身起跳更远，所以它的最远距离就是前一下标的最远距离，而前一下标的最远距离同样是要么以自身起跳、要么从更前的某个下标起跳

          - 令$DP_i$表示跳跃经过下标$i$时能跳到的最远的下标，则有如下递推方程：

            $DP_i = max\left\{\begin{array}{l}
            a_i \\
            DP_{i-1} \\
            \end{array}\right.$

          - 当某一下标的最远距离计算出来可以到达最后一个下标时就可以返回结果，或者某次遍历发现前一下标的最远距离无法到达当前下标时结束计算并返回失败的结果
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【贪心法】
      - 分析
        - 【直觉切入】
          - 问题解答只需要遍历所有下标，当发现某个下标起跳时能否达到最末尾就可以确定答案。而某下标是否能遍历，取决于之前某个下标起跳能否到达该下标
          - 因此设置动态变量在每次遍历时记录当前遍历到的下标起跳最远能到达哪里，并在该最远跳跃范围内继续遍历。直到最远跳跃范围无法继续更新，而范围内又没有下标能跳跃到最末尾时返回失败
        - 【动态规划切入：记忆简化】
          - 动态规划的分析中，可以发现，我们需要记忆的只有前一下标的最远距离，它意味着当前下标$i$之前某个下标起跳的最远距离
          - 因此我们只需在遍历中不断的在自身起跳和之前起跳之间选择最大值，并将最大值更新到之前起跳的记忆变量中，就可以在下一次遍历继续比对并更新，直到某次遍历中发现能到达最远下标
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [62.不同路径](https://leetcode-cn.com/problems/unique-paths/)（[我的实现](questions/wrong/62.不同路径.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【动态规划】
      - 分析
        - 【TODO】
          - 对于矩阵任一格$(i,j)$，只可能从$(i,j-1)$向下走一步、或从$(i-1,j)$向右走一步过来，因此到达$(i,j)$的路径数量是到达$(i-1,j)$和$(i,j-1)$两格的路径总和，而题目的解是到达$(m,n)$的路径数量
          - 令$DP_{ij}$为到达某格$(i,j)$的路径数量，则有$DP_{ij} = DP{i-1,j} + DP{i,j-1}$
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【排列组合】
      - 分析
        - 【TODO】
          - 从左上角移动到右下角，无论如何移动都是至少要移动$(m-1)+(n-1)=m+n-2$步，其中必有$m-1$次向下移动和$n-1$次向右移动
          - 不同的路径可以看作是$m-1$次向下移动和$n-1$次向右移动的排列组合，如果按照直觉思维即“第一次移动有两个分支即下或右，然后第二次移动在第一次移动的两个分支基础上再继续分裂下或右的分支，...”去思考会把问题复杂化
          - 这个排列组合可以看作是一个大小为$m+n-2$的移动集合，从中选出$m-1$个移动作为向下移动（或等价地，从中选出$n-1$个移动作为向右移动），注意这是组合而不是排列，因为选择的次序无关。先选择第i次移动向下、后选择第j次移动向右，和先选第j次移动向右、后选择第i次行动向下；这二者的次序不影响结果
          - 因此该问题的计算公式或者说数学模型是：

            $
            C(m+n-2, m-1)=\left(\begin{array}{c}m+n-2\\m-1\end{array}\right)=\frac{(m+n-2)!}{(m-1)!(n-1)!}
            $

            计算机是用循环乘来计算阶乘的，计算上式时会比较麻烦：

            - 如果分子和分母的两个因子单独循环计算出结果，然后分母因子相乘再被分子除，很容易溢出。阶乘的结果往往比较大
            - 如果控制在一个循环里，每次循环都计算各部分的一个阶，然后立刻计算相除结果并暂存，则循环条件会因为分子分母各自循环条件的差异而变得不好写：分母要循环$m+n-2$次，分子的两个因子分别要循环$m-1$次和$n-1$次该公式

            所以为了方便计算机计算排列组合，上式一般会整理成如下形式，使得各部分循环条件统一循环m次：

            $
            C(m+n-2, m-1)=\frac{(m+n-2)(m+n-3)...(n+1)n}{(m-1)!}
            $

          - 计算该公式要循环m次，所以复杂度是O(m)。但因为选择向下或者选择向右都是等价问题，所以m和n是可以互换的，可以选择行数和列数较小的那个作为循环次数，使得复杂度为O(min(m,n))

      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [322.零钱兑换](https://leetcode-cn.com/problems/coin-change/)（[我的实现](questions/accepted/322.零钱兑换.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【最优子结构】
      - 任一金额的最小钞票数量，都可以通过计算更小金额的最小钞票数量来求解，而计算哪些更小的金额则取决于钞票面额的集合。比如10元的金额在钞票面额集合为{1元，2元，5元}时，可以通过计算金额为10-1=9元、10-2=8元、10-5=5元，这些通过减去1张钞票面额计算出来的更小金额，都可以直接逆计算即加上被减去的钞票面额得到10元，换言之，这些金额都可以加上一张有被减去的面额的钞票来凑齐10元：
        - 9元：9元本身需要3张钞票（2张2元，1张5元），再加上一张1元钞票就可以凑齐10元，总共4张
        - 8元：8元本身需要3张钞票（1张1元，1张2元，1张5元），再加上一张2元钞票就可以凑齐10元，总共4张
        - 5元：5元本身需要1张钞票（1张5元），再加上一张5元钞票就可以凑齐10元，总共2张
      - 令$F(i)$表示凑齐$i$元需要的最小钞票数量，令$c_j$为钞票面额，令$n$为钞票面额集合大小，则递推式如下：

        $F(i)=\underset{j=1..n}{min}F(i-c_j)+1=min\left\{\begin{array}{l}
        F(i-c_1)+1 \\
        F(i-c_2)+1 \\
        ... \\
        F(i-c_n)+1 \\
        \end{array}\right.$

    - 【记忆化搜索】
      - 上述递推式在计算时会重复计算许多中间结果，因此从$F(0)$、$F(1)$开始算起并记录中间结果以在后续计算中使用，可以节省大量计算时间

  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

### 二分查找最后出现

二分查找的变体，结合查找目的，每次二分查找时的三种情况中，等于目标值的情况有所不同：

- $A_{mid} = T$：找到目标值，则目标值最后出现的位置不可能在中值左侧区域$[l .. mid]$内，只可能在当前的中值位置，或者，右侧区域$[mid+1 .. r]$内，因此令$l = mid+1$

即遇到等于目标值的元素也要像小于目标值那样，向右移动：

- $A_{mid} \le T$：右移，令$l = mid+1$
- $A_{mid} > T$：左移，令$r = mid-1$

这个算法的正确性证明：

循环不变式：目标值$T$如果存在与数组$A$中，则目标值第一次出现的位置要么被记录为$I$，要么存在于区域$A[l .. r]$内

- 初始化：初始时$l=0$，$r=len(A)$，计算区域覆盖整个数组，此时循环不变式必然是成立的
- 保持：循环时，有如下操作，循环不变式依然成立：
  - $A_{mid} = T$：找到目标值，则目标值最后出现的位置不可能在中值左侧区域$[l .. mid]$内，只可能在当前的中值位置，或者，右侧区域$[mid+1 .. r]$内，因此令$I = mid$，令$r = mid-1$。循环不变式依旧成立
  - $A_{mid} < T$：目标值最后出现的位置不可能在中值左侧区域$[l .. mid]$内，只可能在右侧区域$[mid+1 .. r]$内，令$l = mid+1$。循环不变式依旧成立
  - $A_{mid} > T$：目标值最后出现的位置不可能在中值右侧区域$[mid .. r]$内，只可能在左侧区域$[l .. mid-1]$内，令$r = mid-1$。循环不变式依旧成立
- 终止：$l > r$时停机：
  - $I$没有赋值：目标值不在数组内
  - $I$有赋值：$I$就是目标值最后出现位置

## 哈希

最优解为哈希的问题一般有如下特性：

- 【集合环境依赖】集合中某个元素的条件判定与集合内其他元素或其他集合有关

- [1.两数之和](questions/accepted/1.两数之和.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：
    - 【集合环境依赖】
      - 数组内某元素是不是两数和组成部分的判定，取决于数组内其他元素的状态，具体来说就是有无一个元素与该元素的和恰好是目标值
  - 解法
    - 【哈希】Time=O(n), Space=O(n)
      - 构建一个以元素值为键，元素值下标为值的哈希表
      - 遍历每个元素，计算目标值减去元素的差值是否在表中：
        - 若存在，则返回该键的值与当前元素下标值组成的二元组
        - 若不存在，则插入以元素值为键，元素下标为值的键值对入表

- [217.存在重复元素](questions/accepted/217.存在重复元素.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：
    - 【集合环境依赖】
      - 一个数组是否存在重复元素的判定，可以解释为数组中各个元素是否重复的判定
      - 数组中某元素是否重复的判定，取决于数组内其他元素的状态，具体来说就是其他元素的值有没有和该元素相同的
  - 解法
    - 【哈希】Time=O(n), Space=O(n)
      - 对每个元素，将其插入集合中，若发现集合中已存在，则存在重复元素

- [242.有效的字母异位词](questions/optimizable/242.有效的字母异位词.rs)
  - 条件
    - 【ASCII字符串】
  - 分析：
    - 【集合环境依赖】
      - 两个字符串是否为字母异位词的判定，可以解释为一个串中每个字符值出现次数是否与另一串等同
      - 一个串中某字符的值是否在交集内的判定，取决于该数组内其他元素的状态以及另一数组内元素的状态，具体来说就是当前数组内的同值元素和另一数组内的同值元素出现次数
  - 解法
    - 【哈希】Time=O(n), Space=O($\Sigma$)
      - 构建一个以字符值为键，字符出现次数为值的哈希表
      - 遍历其中一个字符串，将字符出现频次统计入哈希表
      - 遍历另一个字符串：
        - 字符值不在哈希表中，则不是异位词，返回结果
        - 字符值在哈希表中则对应的出现次数-1，若-1后为0，则移除该键值对
      - 遍历结束后，若哈希表为空，则为异位词

- [350.两个数组的交集-ii](questions/accepted/350.两个数组的交集-ii.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析
    - 【集合环境依赖】
      - 一个数组某元素是否在交集内的判定，取决于该数组内其他元素的状态以及另一数组内元素的状态，具体来说就是当前数组内的同值元素和另一数组内的同值元素出现次数
  - 解法
    - 【哈希】Time=O(m + n), Space=O( min(m, n) )
      - 使用以元素值为键，出现次数为值的哈希表
      - 遍历较短的数组，记录每个元素的出现次数
      - 遍历另一数组，对存在于哈希表中的元素，将元素记录到返回结果中，并将次数-1。若次数-1后为0，则从哈希表移除该元素

- [387.字符串中的第一个唯一字符](questions/accepted/387.字符串中的第一个唯一字符.rs)
  - 条件
    - 【ASCII字符串】
  - 分析
    - 【集合环境依赖】
      - 字符串中的某个字符是否唯一的判定，取决于字符串内其他字符的状态，具体来说就是其他字符有没有和该字符相同的
  - 解法
    - 【哈希】Time=O(n), Space=O($\Sigma$)
      - 构建一个以元素值为键，元素出现次数为值的哈希表
      - 遍历字符串，统计元素出现次数到哈希表中
      - 遍历哈希表，遇到次数为1的元素记录就返回结果

### 哈希+状态位串

- [36.有效的数独](questions/accepted/36.有效的数独.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析
    - 【集合环境依赖】
      - 数独是否有效的判定，可以解释为数独矩阵每个数字是否有效的判定
      - 数度矩阵每个元素是否有效的判定，可解释为该元素在三个集合中是否有效的判定
      - 每个元素在对应的三个集合中是否有效的判定，取决于三个集合内部其他元素的状态。具体来说该元素值对应的列集合、行集合和宫集合的其他元素有无重复值
    - 【定长布尔状态集】
      - 因为三个元素状态集只需要记录元素是否存在即可，可解释为布尔值
      - 又因为元素的键值就是元素值本身而其值域只有1-9，是固定且较小的值域
      - 所以可以用一个长度合适的位串来记录元素状态，元素键值映射对应的位是0还是1来记录元素是否存在
  - 解法
    - 【哈希】+【布尔串】Time=O(a * a), Space=O(a + a + a)
      - 构建三个哈希表：
        - 行哈希表：以行号为键，以位数大于等于列数a的位串为值
        - 列哈希表：以列号为键，以位数大于等于行数a的位串为值
        - 宫哈希表：以宫号为键，以位数大于等于宫数a的位串为值
      - 遍历矩阵每个元素(i,j)：
        - 将1按位右移，偏移量等于该元素值，所得结果作为元素模式
        - 元素模式与行哈希表第i行对应的位串按位与操作：
          - 结果==0：将元素模式以按位或操作的方式更新到行哈希表第i行对应的位串
          - 结果!=0：判别为无效数独并返回结果
        - 元素模式与列哈希表第j列对应的位串按位与操作：
          - 结果==0：将元素模式以按位或操作的方式更新到列哈希表第j列对应的位串
          - 结果!=0：判别为无效数独并返回结果
        - 元素模式与宫哈希表第(i/3+j/3)宫对应的位串按位与操作：
          - 结果==0：将元素模式以按位或操作的方式更新到宫哈希表第(i/3+j/3)宫对应的位串
          - 结果!=0：判别为无效数独并返回结果

## 双指针

- [26.删除有序数组中的重复项](questions/accepted/26.删除有序数组中的重复项.rs)：
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
    - 【有序】因为数组是有序的，重复项必定相邻
  - 分析：TODO
  - 解法
    - 【双指针】Time=O(n), Space=O(1)
      - 将数组分割成两部分，前一部分不重复，后一部分可能重复
      - 左指针指向不重复数组的末端，左指针之前没有重复，之后可能存在重复
      - 右指针向前探索不断寻找左指针之前没有的值，然后将其加入左指针之前的数组，左指针则配合着前进一步来扩大不重复数组范围

- [125.验证回文串](questions/accepted/125.验证回文串.rs)
  - 条件
    - 【ASCII字符串】
  - 分析：TODO
  - 解法
    - 【双指针】Time=O($log_2n$), Space=O(1)
      1. 左指针指向字符串头，右指针指向字符串尾，左右指针相向移动，步长为1
      1. 左右指针都跳过非字母的字符
      1. 检查左右指针指向的字符值是否相等
         - 若相等，左右指针移动一步，回到(2)
         - 若不等，则不是回文串，返回结果
      1. 重复(2)(3)直到左指针和右指针相等或交错

- [283.移动零](questions/accepted/283.移动零.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：TODO
  - 解法
    - 【双指针】Time=O(n), Space=O(1)
      - 将数组分割成两部分，前一部分没有0，后一部分可能有0
      - 左指针指向非0数组的末端，左指针之前没有0，之后可能存在0
      - 右指针向前探索不断寻找非0值，然后将其加入左指针之前的数组，左指针则配合着前进一步来扩大不重复数组范围

- [344.反转字符串](questions/accepted/344.反转字符串.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：TODO
  - 解法
    - 【双指针】Time=O(n), Space=O(1)
      - 左指针从数组头开始，右指针从数组尾开始
      - 交换两个指针所指的值
      - 左指针向尾移动一步，右指针向头移动一步

## 动态规划

题目带有如下性质时，一般可以用动态规划求最优解：

- 【递归求最值】含有递归性质，且题目任务是求最值

### 贪心法

- [122.买卖股票的最佳时机-ii](questions/optimizable/122.买卖股票的最佳时机-ii.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：TODO
  - 解法
    - 【贪心法】Time=O(n), Space=O(1)
      - 对数组每个元素检查是否比下一元素小
      - 若是，则将二者的差累加到返回值
