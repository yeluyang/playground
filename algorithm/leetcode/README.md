# 算法题笔记

[TOC]

- [189.旋转数组](questions/wrong/189.旋转数组.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 分析：TODO
  - 解法
    - 【数组翻转】Time=O($\log_2n$), Space=O(1)
      - 翻转整个数组
      - 翻转数组`[0, k)`的切片
      - 翻转数组`[k, n)`的切片
    - 【环状替换】Time=O(n), Space=O(1)

- [136.只出现一次的数字](questions/wrong/136.只出现一次的数字.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
    - 【偶数次重复】重复元素都重复两次
    - 【不重复元素唯一】不重复元素只有一个
  - 分析：TODO
  - 解法
    - 【数学：异或位运算】Time=O(n), Space=O(1)
      - 异或位运算有如下性质：
        - $ a \oplus 0 = a $
        - $ a \oplus a = 0 $
        - $ a \oplus b = b \oplus a $
        - $ a \oplus b \oplus c = a \oplus (b \oplus c) $
      - 将整个数组所有元素一起进行异或运算，据异或位运算的性质，可以过滤掉数组内所有偶数次重复的元素，留下唯一不重复的元素：

        $ a \oplus b \oplus a = (a \oplus a) \oplus b = 0 \oplus b = b $

- [66.加一](questions/accepted/66.加一.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 分析：TODO
  - 解法
    - 【逆序遍历】Time=O(n), Space=O(1)
      - 从数组尾部向前进行逆序遍历：
        - 当前元素=9，则置0
        - 当前元素<9，则+1，并返回
      - 遍历结束意味着该数字每一位都是9，则分配一个size+1的数组，并将数组首位置1，其余元素置0，然后返回该新数组

- [48.旋转图像](questions/wrong/48.旋转图像.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 分析：TODO
  - 解法
    - 【先上下翻转，再对角线翻转】Time=O($n\log_2n$) Space=O(1)
      - 以矩阵中间为对称轴，上下翻转矩阵
      - 以对角线为对称轴，翻转矩阵

- [7.整数反转](questions/wrong/7.整数反转.rs)
  - 条件
    - 【32位】算法运行环境是32位环境，每次计算不准有多于32位的数据
  - 分析：TODO
  - 解法
    - 【数学：溢出判断】Time=O(n), Space=O(1)
      - 要保证翻转后的数字不会溢出，只要如下不等式成立即可：
        $ -2^{31} \leq reverse \times 10 + digit \leq 2^{31}-1 $
        该不等式可以简化为:
        $ \lceil \frac{-2^{31}}{10} \rceil \leq reverse \leq \lfloor \frac{2^{31}-1}{10} \rfloor $
      - 使用求模再除10的方法，从最低位逐位取出该位数值
      - 再使用乘10后相加的方法，把该数值添加到反转数当前的最低位上
      - 使用上面的简化后的不等式判定反转数的当前值，不符合判定则返回错误
    - 【逆运算还原检查】Time=O(n), Space=O(1)
      - 使用求模再除10的方法，从最低位逐位取出该位数值
      - 再使用乘10后相加的方法，把该数值添加到反转数当前的最低位上
      - 对当前反转数做上一步的逆运算，检查逆运算结果是否与反转数的上一数值等同。若不等同意味着有溢出，返回错误

- [8.字符串转换整数-atoi](questions/wrong/8.字符串转换整数-atoi.rs)
  - 条件
    - 【ASCII字符串】
  - 分析：TODO
  - 解法
    - 【确定有限状态机 + 数学：溢出判断】Time=O(n), Space=O(1)
      - 初始状态：
        - 遍历到空格不做处理
        - 遍历到数字转移到“数字状态”
        - 遍历到正负号转移到“符号状态”
        - 遍历到其他字符转移到“结束状态”
      - 数字状态：
        - 遍历到非数字转移到“结束状态”
        - 遍历到数字则推入最终结果，并做溢出判断
      - 符号状态：
        - 遍历到数字则转移到“数字状态”
        - 遍历到非数字则转移到“结束状态”
      - 结束状态：返回最终结果与符号

- [28.实现-str-str](questions/wrong/28.实现-str-str.rs)
  - 条件
    - 【ASCII字符串】
  - 分析：TODO
  - 解法
    - 【子串匹配：KMP算法】

- [38.外观数列](questions/accepted/38.外观数列.rs)
  - 条件
  - 分析：TODO
  - 解法
    - 【字符串遍历】

- [14.最长公共前缀](questions/optimizable/14.最长公共前缀.rs)
  - 条件
    - 【字符串数组】
  - 分析：TODO
  - 解法
    - 【矩阵横向查找】
      - 步骤
        1. 以矩阵第一行作为前缀模式初值
        1. 以行遍历的方式从第二行开始逐字符匹配：
           - 相等：比对下一字符
           - 不等：比对下一行
        1. 遍历结束后，返回前缀模式
      - 复杂度
        - 时间：
          - O(m*n)，n是字符串数量，m是字符串平均长度
          - 在内存以行存储矩阵且共同前缀较长时，性能优于其他方法
        - 空间：O(1)
    - 【矩阵纵向查找】
      - 步骤
        1. 以列遍历的方式检查字符矩阵每一列是否相等：
           - 相等：检查下一列
           - 不等：返回任一行的0列到前一列的内容为最终结果
      - 复杂度
        - 时间：
          - O(m*n)，n是字符串数量，m是字符串平均长度
          - 在内存以列存储或者共同前缀非常短时，性能优于其他方法
        - 空间：O(1)

## 哈希

最优解为哈希的问题一般有如下特性：

- 【集合环境依赖】集合中某个元素的条件判定与集合内其他元素或其他集合有关

- [1.两数之和](questions/accepted/1.两数之和.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 分析：
    - 【集合环境依赖】
      - 数组内某元素是不是两数和组成部分的判定，取决于数组内其他元素的状态，具体来说就是有无一个元素与该元素的和恰好是目标值
  - 解法
    - 【哈希】Time=O(n), Space=O(n)
      - 构建一个以元素值为键，元素值下标为值的哈希表
      - 遍历每个元素，计算目标值减去元素的差值是否在表中：
        - 若存在，则返回该键的值与当前元素下标值组成的二元组
        - 若不存在，则插入以元素值为键，元素下标为值的键值对入表

- [217.存在重复元素](questions/accepted/217.存在重复元素.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 分析：
    - 【集合环境依赖】
      - 一个数组是否存在重复元素的判定，可以解释为数组中各个元素是否重复的判定
      - 数组中某元素是否重复的判定，取决于数组内其他元素的状态，具体来说就是其他元素的值有没有和该元素相同的
  - 解法
    - 【哈希】Time=O(n), Space=O(n)
      - 对每个元素，将其插入集合中，若发现集合中已存在，则存在重复元素

- [242.有效的字母异位词](questions/optimizable/242.有效的字母异位词.rs)
  - 条件
    - 【ASCII字符串】
  - 分析：
    - 【集合环境依赖】
      - 两个字符串是否为字母异位词的判定，可以解释为一个串中每个字符值出现次数是否与另一串等同
      - 一个串中某字符的值是否在交集内的判定，取决于该数组内其他元素的状态以及另一数组内元素的状态，具体来说就是当前数组内的同值元素和另一数组内的同值元素出现次数
  - 解法
    - 【哈希】Time=O(n), Space=O($\Sigma$)
      - 构建一个以字符值为键，字符出现次数为值的哈希表
      - 遍历其中一个字符串，将字符出现频次统计入哈希表
      - 遍历另一个字符串：
        - 字符值不在哈希表中，则不是异位词，返回结果
        - 字符值在哈希表中则对应的出现次数-1，若-1后为0，则移除该键值对
      - 遍历结束后，若哈希表为空，则为异位词

- [350.两个数组的交集-ii](questions/accepted/350.两个数组的交集-ii.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 分析
    - 【集合环境依赖】
      - 一个数组某元素是否在交集内的判定，取决于该数组内其他元素的状态以及另一数组内元素的状态，具体来说就是当前数组内的同值元素和另一数组内的同值元素出现次数
  - 解法
    - 【哈希】Time=O(m + n), Space=O( min(m, n) )
      - 使用以元素值为键，出现次数为值的哈希表
      - 遍历较短的数组，记录每个元素的出现次数
      - 遍历另一数组，对存在于哈希表中的元素，将元素记录到返回结果中，并将次数-1。若次数-1后为0，则从哈希表移除该元素

- [387.字符串中的第一个唯一字符](questions/accepted/387.字符串中的第一个唯一字符.rs)
  - 条件
    - 【ASCII字符串】
  - 分析
    - 【集合环境依赖】
      - 字符串中的某个字符是否唯一的判定，取决于字符串内其他字符的状态，具体来说就是其他字符有没有和该字符相同的
  - 解法
    - 【哈希】Time=O(n), Space=O($\Sigma$)
      - 构建一个以元素值为键，元素出现次数为值的哈希表
      - 遍历字符串，统计元素出现次数到哈希表中
      - 遍历哈希表，遇到次数为1的元素记录就返回结果

### 哈希+状态位串

- [36.有效的数独](questions/accepted/36.有效的数独.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 分析
    - 【集合环境依赖】
      - 数独是否有效的判定，可以解释为数独矩阵每个数字是否有效的判定
      - 数度矩阵每个元素是否有效的判定，可解释为该元素在三个集合中是否有效的判定
      - 每个元素在对应的三个集合中是否有效的判定，取决于三个集合内部其他元素的状态。具体来说该元素值对应的列集合、行集合和宫集合的其他元素有无重复值
    - 【定长布尔状态集】
      - 因为三个元素状态集只需要记录元素是否存在即可，可解释为布尔值
      - 又因为元素的键值就是元素值本身而其值域只有1-9，是固定且较小的值域
      - 所以可以用一个长度合适的位串来记录元素状态，元素键值映射对应的位是0还是1来记录元素是否存在
  - 解法
    - 【哈希】+【布尔串】Time=O(a * a), Space=O(a + a + a)
      - 构建三个哈希表：
        - 行哈希表：以行号为键，以位数大于等于列数a的位串为值
        - 列哈希表：以列号为键，以位数大于等于行数a的位串为值
        - 宫哈希表：以宫号为键，以位数大于等于宫数a的位串为值
      - 遍历矩阵每个元素(i,j)：
        - 将1按位右移，偏移量等于该元素值，所得结果作为元素模式
        - 元素模式与行哈希表第i行对应的位串按位与操作：
          - 结果==0：将元素模式以按位或操作的方式更新到行哈希表第i行对应的位串
          - 结果!=0：判别为无效数独并返回结果
        - 元素模式与列哈希表第j列对应的位串按位与操作：
          - 结果==0：将元素模式以按位或操作的方式更新到列哈希表第j列对应的位串
          - 结果!=0：判别为无效数独并返回结果
        - 元素模式与宫哈希表第(i/3+j/3)宫对应的位串按位与操作：
          - 结果==0：将元素模式以按位或操作的方式更新到宫哈希表第(i/3+j/3)宫对应的位串
          - 结果!=0：判别为无效数独并返回结果

## 双指针

- [26.删除有序数组中的重复项](questions/accepted/26.删除有序数组中的重复项.rs)：
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
    - 【有序】因为数组是有序的，重复项必定相邻
  - 分析：TODO
  - 解法
    - 【双指针】Time=O(n), Space=O(1)
      - 将数组分割成两部分，前一部分不重复，后一部分可能重复
      - 左指针指向不重复数组的末端，左指针之前没有重复，之后可能存在重复
      - 右指针向前探索不断寻找左指针之前没有的值，然后将其加入左指针之前的数组，左指针则配合着前进一步来扩大不重复数组范围

- [125.验证回文串](questions/accepted/125.验证回文串.rs)
  - 条件
    - 【ASCII字符串】
  - 分析：TODO
  - 解法
    - 【双指针】Time=O($log_2n$), Space=O(1)
      1. 左指针指向字符串头，右指针指向字符串尾，左右指针相向移动，步长为1
      1. 左右指针都跳过非字母的字符
      1. 检查左右指针指向的字符值是否相等
         - 若相等，左右指针移动一步，回到(2)
         - 若不等，则不是回文串，返回结果
      1. 重复(2)(3)直到左指针和右指针相等或交错

- [283.移动零](questions/accepted/283.移动零.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 分析：TODO
  - 解法
    - 【双指针】Time=O(n), Space=O(1)
      - 将数组分割成两部分，前一部分没有0，后一部分可能有0
      - 左指针指向非0数组的末端，左指针之前没有0，之后可能存在0
      - 右指针向前探索不断寻找非0值，然后将其加入左指针之前的数组，左指针则配合着前进一步来扩大不重复数组范围

- [344.反转字符串](questions/accepted/344.反转字符串.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 分析：TODO
  - 解法
    - 【双指针】Time=O(n), Space=O(1)
      - 左指针从数组头开始，右指针从数组尾开始
      - 交换两个指针所指的值
      - 左指针向尾移动一步，右指针向头移动一步

## 动态规划

题目带有如下性质时，一般可以用动态规划求最优解：

- 【递归求最值】含有递归性质，且题目任务是求最值

### 贪心法

- [122.买卖股票的最佳时机-ii](questions/optimizable/122.买卖股票的最佳时机-ii.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以顺序读取也可以随机读取
  - 分析：TODO
  - 解法
    - 【贪心法】Time=O(n), Space=O(1)
      - 对数组每个元素检查是否比下一元素小
      - 若是，则将二者的差累加到返回值
