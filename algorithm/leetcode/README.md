# 算法题笔记

[TOC]

- [189.旋转数组](questions/wrong/189.旋转数组.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：TODO
  - 解法
    - 【数组翻转】Time=O($\log_2n$), Space=O(1)
      - 翻转整个数组
      - 翻转数组`[0, k)`的切片
      - 翻转数组`[k, n)`的切片
    - 【环状替换】Time=O(n), Space=O(1)

- [136.只出现一次的数字](questions/wrong/136.只出现一次的数字.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
    - 【偶数次重复】重复元素都重复两次
    - 【不重复元素唯一】不重复元素只有一个
  - 分析：TODO
  - 解法
    - 【数学：异或位运算】Time=O(n), Space=O(1)
      - 异或位运算有如下性质：
        - $ a \oplus 0 = a $
        - $ a \oplus a = 0 $
        - $ a \oplus b = b \oplus a $
        - $ a \oplus b \oplus c = a \oplus (b \oplus c) $
      - 将整个数组所有元素一起进行异或运算，据异或位运算的性质，可以过滤掉数组内所有偶数次重复的元素，留下唯一不重复的元素：

        $ a \oplus b \oplus a = (a \oplus a) \oplus b = 0 \oplus b = b $

- [66.加一](questions/accepted/66.加一.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：TODO
  - 解法
    - 【逆序遍历】Time=O(n), Space=O(1)
      - 从数组尾部向前进行逆序遍历：
        - 当前元素=9，则置0
        - 当前元素<9，则+1，并返回
      - 遍历结束意味着该数字每一位都是9，则分配一个size+1的数组，并将数组首位置1，其余元素置0，然后返回该新数组

- [48.旋转图像](questions/wrong/48.旋转图像.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：TODO
  - 解法
    - 【先上下翻转，再对角线翻转】Time=O($n\log_2n$) Space=O(1)
      - 以矩阵中间为对称轴，上下翻转矩阵
      - 以对角线为对称轴，翻转矩阵

- [7.整数反转](questions/wrong/7.整数反转.rs)
  - 条件
    - 【32位】算法运行环境是32位环境，每次计算不准有多于32位的数据
  - 分析：TODO
  - 解法
    - 【数学：溢出判断】Time=O(n), Space=O(1)
      - 要保证翻转后的数字不会溢出，只要如下不等式成立即可：
        $ -2^{31} \leq reverse \times 10 + digit \leq 2^{31}-1 $
        该不等式可以简化为:
        $ \lceil \frac{-2^{31}}{10} \rceil \leq reverse \leq \lfloor \frac{2^{31}-1}{10} \rfloor $
      - 使用求模再除10的方法，从最低位逐位取出该位数值
      - 再使用乘10后相加的方法，把该数值添加到反转数当前的最低位上
      - 使用上面的简化后的不等式判定反转数的当前值，不符合判定则返回错误
    - 【逆运算还原检查】Time=O(n), Space=O(1)
      - 使用求模再除10的方法，从最低位逐位取出该位数值
      - 再使用乘10后相加的方法，把该数值添加到反转数当前的最低位上
      - 对当前反转数做上一步的逆运算，检查逆运算结果是否与反转数的上一数值等同。若不等同意味着有溢出，返回错误

- [8.字符串转换整数-atoi](questions/wrong/8.字符串转换整数-atoi.rs)
  - 条件
    - 【ASCII字符串】
  - 分析：TODO
  - 解法
    - 【确定有限状态机 + 数学：溢出判断】Time=O(n), Space=O(1)
      - 初始状态：
        - 遍历到空格不做处理
        - 遍历到数字转移到“数字状态”
        - 遍历到正负号转移到“符号状态”
        - 遍历到其他字符转移到“结束状态”
      - 数字状态：
        - 遍历到非数字转移到“结束状态”
        - 遍历到数字则推入最终结果，并做溢出判断
      - 符号状态：
        - 遍历到数字则转移到“数字状态”
        - 遍历到非数字则转移到“结束状态”
      - 结束状态：返回最终结果与符号

- [28.实现-str-str](questions/wrong/28.实现-str-str.rs)
  - 条件
    - 【ASCII字符串】
  - 分析：TODO
  - 解法
    - 【子串匹配：KMP算法】

- [38.外观数列](questions/accepted/38.外观数列.rs)
  - 条件
  - 分析：TODO
  - 解法
    - 【字符串遍历】

- [14.最长公共前缀](questions/optimizable/14.最长公共前缀.rs)
  - 条件
    - 【字符串数组】
  - 分析：TODO
  - 解法
    - 【矩阵横向查找】
      - 步骤
        1. 以矩阵第一行作为前缀模式初值
        1. 以行遍历的方式从第二行开始逐字符匹配：
           - 相等：比对下一字符
           - 不等：比对下一行
        1. 遍历结束后，返回前缀模式
      - 复杂度
        - 时间：
          - O(m*n)，n是字符串数量，m是字符串平均长度
          - 在内存以行存储矩阵且共同前缀较长时，性能优于其他方法
        - 空间：O(1)
    - 【矩阵纵向查找】
      - 步骤
        1. 以列遍历的方式检查字符矩阵每一列是否相等：
           - 相等：检查下一列
           - 不等：返回任一行的0列到前一列的内容为最终结果
      - 复杂度
        - 时间：
          - O(m*n)，n是字符串数量，m是字符串平均长度
          - 在内存以列存储或者共同前缀非常短时，性能优于其他方法
        - 空间：O(1)

- [237.删除链表中的节点](questions/wrong/237.删除链表中的节点.c)
  - 条件
    - 【单链表】单链表数据结构，可以顺序访问，不能随机访问，不能逆序访问。任何位置的插入删除操作开销都很低
    - 【从中间开始】只给出指定要删除节点且保证不是尾节点，不给出链表头节点
  - 分析：TODO
  - 解法
    - 【TODO】Time=O(1), Space=O(1)
      1. 将指定节点的下一节点的值赋给指定节点
      1. 将指定节点的下一节点的next赋给指定节点
      1. 将指定节点的下一节点作为要删除的节点，删除释放掉

- [19.删除链表的倒数第-n-个结点](questions/accepted/19.删除链表的倒数第-n-个结点.rs)
  - 条件
    - 【单链表】单链表数据结构，可以顺序访问，不能随机访问，不能逆序访问。任何位置的插入删除操作开销都很低
  - 分析：TODO
  - 解法
    - 【快慢指针】Time=O(n), Space=O(1)
      1. 快指针前进n步后，慢指针再开始前进，保持快指针领先慢指针n个节点
      1. 快指针遍历完链表成为空指针时，慢指针就指向了倒数第n个节点，删除慢指针指向的节点即可

- [206.反转链表](questions/accepted/206.反转链表.rs)
  - 条件
    - 【单链表】单链表数据结构，可以顺序访问，不能随机访问，不能逆序访问。任何位置的插入删除操作开销都很低
  - 分析：TODO
  - 解法
    - 【TODO】Time=O(n), Space=O(1)
      1. 设置3个指针，cur指向当前要翻转的节点，next指向cur的下一节点，pre指向cur的前一节点
      1. 设置cur指针的next指向pre
      1. 更新pre指向cur
      1. 更新cur指向next
      1. 更新next指向cur.next
      1. 回到(2)，重复直到cur为空

- [21.合并两个有序链表](questions/accepted/21.合并两个有序链表.rs)
  - 条件
    - 【单链表】单链表数据结构，可以顺序访问，不能随机访问，不能逆序访问。任何位置的插入删除操作开销都很低
    - 【有序】两个单链表的节点值是升序的
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 算法
        1. 创建一个新的链表头节点
        1. 两个链表中的较小的头节点取出来加入到新链表
        1. 回到(2)，重复直到其中一个链表为空
        1. 将另一个不空的链表整个添加到新链表
        1. 返回新链表
      - 复杂度
        - 时间：O(m + n)，“m”和“n”是两个链表的长度
        - 空间：O(1)

- [234.回文链表](questions/wrong/234.回文链表.rs)
  - 条件
    - 【单链表】单链表数据结构，可以顺序访问，不能随机访问，不能逆序访问。任何位置的插入删除操作开销都很低
  - 分析
    - 【TODO】
  - 解法
    - 【快慢指针】
      - 分析
        - 【快慢指针步长倍数是遍历元素数量的倍数】快慢指针步长的倍数为n，则当快指针遍历全部元素时，慢指针恰好遍历完1/n的元素
      - 步骤
        1. 设置快慢指针同时从头节点出发向尾节点前进
        1. 遍历链表并更新快慢指针：
           - 快指针每次前进两步，同时累加链表节点计数
           - 慢指针每次前进一步，每次离开一个节点前，先反转该节点的next指向原来的前序节点
        1. 重复(2)，直到快指针到尾节点，此时，慢指针正好在链表中间，而链表前半部分则被翻转：
        1. 快指针重置为慢指针的next
        1. 根据链表节点数量的奇偶性分别处理
           - 链表节点数为偶数：不做处理
           - 链表节点数为奇数：
             1. 慢指针重置为前一个节点
        1. 快指针向尾节点前进，慢指针向头节点前进，两指针每次前进一步：
           1. 修复该节点被慢指针修改的next
           1. 检查节点值：
            - 节点值相等：继续前进
            - 节点值不等：修复剩余被慢指针修改的链表顺序，然后返回无效回文判定
      - 复杂度
        - 时间：O(n)
        - 空间：O(1)
    - 【全局变量递归】
      - 分析
        - 【TODO】
      - 步骤
        1. 设置一个指向头节点的全局变量后，开始递归
        1. 从头节点开始递归处理：
           1. 检查当前节点是否为空节点：
              - 空节点：返回有效回文判定
              - 非空节点：递归处理该节点的next节点，并检查其返回的判定是不是有效回文：
                - 无效回文：直接返回无效回文的判定
                - 有效回文：
                  1. 检查当前节点与全局节点的值是否相等：
                     - 相等：更新全局节点指向其next节点，然后返回有效回文判定
                     - 不等：直接返回无效回文判定
      - 复杂度
        - 时间：O(n)
        - 空间：O(1)

- [141.环形链表](questions/wrong/141.环形链表.c)
  - 条件
    - 【单链表】单链表数据结构，可以顺序访问，不能随机访问，不能逆序访问。任何位置的插入删除操作开销都很低
  - 分析
    - 【TODO】
  - 解法
    - 【快慢指针】
      - 分析
        - 【TODO】
      - 步骤
        1. 设置快慢指针同时从头节点出发向尾节点前进
        1. 使用快慢指针遍历链表：
           1. 快指针每次前进两步，并检查遍历过的两个节点是否被慢指针指向：
              1. 是慢指针指向：返回有环的判定
              1. 不是慢指针指向：继续遍历
           1. 慢指针每次前进一步
        1. 重复(2)，直到快指针遍历到链表尾节点时返回无环的判定
      - 复杂度
        - 时间：O(n)
        - 空间：O(1)

- [104.二叉树的最大深度](questions/accepted/104.二叉树的最大深度.rs)
  - 条件
    - 【二叉树】TODO
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 步骤
        1. 检查当前递归节点是否为空：
           - 空：返回深度=0
           - 非空：
              1. 递归计算左子树深度
              1. 递归计算右子树深度
              1. 取左右子树最大深度值，加一后返回
      - 复杂度
        - 时间：O(n)
        - 空间：O($log_2n$)
    - 【广度优先遍历】
      - 步骤
        1. 广度优先遍历时，每次都先把队列内所有节点全部出队再遍历。这样能保证任意时刻队列内的节点都处于统一深度
      - 复杂度
        - 时间：O(n)
        - 空间：O($log_2n$)
    - 【深度优先遍历】
      - 步骤
        1. 使用双栈，并在深度优先遍历时，每次节点入栈都把该节点深度同步入另一个栈
      - 复杂度
        - 时间：O(n)
        - 空间：O($log_2n$)

- [98.验证二叉搜索树](questions/wrong/98.验证二叉搜索树.rs)
  - 条件
    - 【二叉树】TODO
    - 【有序】TODO
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 步骤
      1. 使用值域区间来递归处理每个节点：
         1. 检查当前节点是否处于区间内：
            - 否：返回无效搜索树判定
            - 是：
              1. 递归处理左子树，并将值域区间的下限保留，上限改为自身值
              1. 递归处理右子树，并将值域区间的上限保留，下限改为自身值
      - 复杂度
        - 时间：O(n)
        - 空间：O($nlog_2n$)
    - 【中序遍历】
      - 分析
        - 【TODO】
      - 步骤
        1. 中序遍历过程中：
           1. 出栈前先记录当前节点为pre
           1. 出栈后检查出栈节点是否大于pre：
              1. 否：返回无效搜索树判定
              1. 是：检查出站节点是否小于其右子节点：
                 1. 否：返回无效搜索判定
                 1. 是：继续中序遍历
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [101.对称二叉树](questions/wrong/101.对称二叉树.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 步骤
        1. 从根节点的左右子节点开始递归
        1. 每次递归同时处理两个节点：
           1. 两个节点是否有空结点：
              - 两个都是空：返回有效对称判定
              - 仅有一个空：返回无效对称判定
              - 两个都非空：检查两个节点值是否相等：
                - 不等：返回无效对称判定
                - 相等：
                  1. 递归处理左节点的左子树和右节点的右子树
                  1. 递归处理左节点的右子树和右节点的左子树
      - 复杂度
        - 时间：O($log_2n$)
        - 空间：O(TODO)

- [102.二叉树的层序遍历](questions/accepted/102.二叉树的层序遍历.rs)
  - 条件
    - 【二叉树】TODO
  - 分析
    - 【TODO】
  - 解法
    - 【广度优先遍历】
      - 步骤
        1. 广度优先遍历时，每次都先把队列内所有节点全部出队再遍历。这样能保证任意时刻队列内的节点都处于统一深度
      - 复杂度
        - 时间：O(n)
        - 空间：O($log_2n$)

- [108.将有序数组转换为二叉搜索树](questions/wrong/108.将有序数组转换为二叉搜索树.rs)
  - 条件
    - 【二叉树】
    - 【有序】
  - 分析
    - 【TODO】
  - 解法
    - 【分治】
      - 分析
        - 【TODO】
      - 步骤
        1. 递归处理整个数组
        1. 每次递归：
           1. 取数组最中间元素作树根
           1. 递归处理数组左半部分得到左子树根并更新到根上
           1. 递归处理数组右半部分得到右子树根并更新到根上
           1. 向上一层返回树根
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [88.合并两个有序数组](questions/wrong/88.合并两个有序数组.rs)
  - 条件
    - 【数组】
    - 【有序】
  - 分析
    - 【TODO】
  - 解法
    - 【尾部归并排序】
      - 分析
        - 【TODO】
      - 步骤
        1. 从两数组尾部元素开始比较，较大的元素填入第一个数组的尾部空间
        1. 其中一个数组被全部比较完后，另一数组余下元素直接填充结果
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [278.第一个错误的版本](questions/wrong/278.第一个错误的版本.rs)
  - 条件
    - 【数组】
    - 【有序】
  - 分析
    - 【TODO】
  - 解法
    - 【二分查找（改）】
      - 分析
        - 【TODO】
      - 步骤
        1. 从中间元素开始二分查找：
           1. API返回false则向后查找
           1. API返回true则向前查找
        1. 全部元素查找完后，返回二分查找的左边界
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [70.爬楼梯](questions/wrong/70.爬楼梯.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【可分治】问题的解可由子问题的解组合而来
  - 解法
    - 【动态规划】
      - 分析
        - 【TODO】
      - 步骤
        1. 检查n是否小于等于1：
           - 是：返回1
           - 否：
             1. 递归计算n-1阶的结果
             1. 递归计算n-2阶的结果
             1. 将两个递归结果相加并返回
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【动态规划+记忆化搜索】+【记忆简化】
      - 分析
        - 【TODO】
      - 步骤
        1. 设置变量v0=1，表示爬0级台阶有1种方法；设置变量v1=1，表示爬1级台阶有1种方法
        1. 要爬n级台阶则迭代n-2次，每次迭代：
           1. 设置临时变量，值等于v0+v1
           1. 将v1的值赋给v0
           1. 将临时变量的值赋给v1
        1. 返回v0+v1的和
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【动态规划+数学建模：矩阵快速幂】
      - 分析
        - 【齐次线性递推式】
          - 动态规划递推式为：$f(n) = f(n-1) + f(n-2)$，这是齐次线性方程，可以直接转换为矩阵递推式：

            $
            \begin{bmatrix}
            f(n+1) \\
            f(n)
            \end{bmatrix} = \begin{bmatrix}
            f(n) + f(n-1) \\
            f(n)
            \end{bmatrix} = \begin{bmatrix}
            1 & 1 \\
            1 & 0
            \end{bmatrix} \begin{bmatrix}
            f(n) \\
            f(n-1)
            \end{bmatrix} = \begin{bmatrix}
            1 & 1 \\
            1 & 0
            \end{bmatrix}^n \begin{bmatrix}
            f(1) \\
            f(0)
            \end{bmatrix}
            $

          - 根据以上递推式结果，可以使用快速幂来求系数矩阵，从而求出$f(n)$，即爬n级有多少种方法的解

      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【动态规划+数学建模：通项公式】
      - 分析
        - 【TODO】
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [121.买卖股票的最佳时机](questions/wrong/121.买卖股票的最佳时机.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【动态规划+记忆化搜索】+【记忆简化】
      - 分析
        - 【TODO】
          - 对于任意交易日来说，当日只有两种情况：
            - 无头寸：无头寸时又有两种情况：
              - 今日卖出：该情况下，利润就是前一交易日的“有头寸”的利润加上今日卖出所得的利润
              - 今日无交易：这意味着前一交易日就没有头寸。该情况下，利润就是前一交易日的“无头寸”的利润
            - 有头寸：有头寸时又有两种情况：
              - 今日买入：该情况下，利润就是当日股票价格的负数，因为买入股票意味着账面暂时损失了买入价格，在卖出之前，利润都是负的
              - 今日无交易：这意味着前一交易日就有头寸。该情况下，利润就是前一交易日的“有头寸”的利润
          - 因此对于任意交易日来说，当日有头寸和无头寸的利润就是：
            - 无头寸利润 = max(今日卖出后无头寸, 今日无交易也无头寸) = max(前一交易日有头寸+今日卖出价格, 前一交易日无头寸利润)
            - 有头寸利润 = max(今日买入后有头寸, 今日无交易但有头寸) = max(-1*今日买入价格, 前一交易日有头寸利润)
          - 令$h(n)$表示第n交易日有头寸利润，$g(n)$表示第n交易日无头寸利润，则n个交易日后的最大利润$f(n)$：

            $
            f(n) = max\left\{\begin{array}{l}
            h(n) = max(-Prices(n), h(n-1)) \\
            g(n) = max(h(n-1)+Prices(n), g(n-1))\\
            \end{array}\right.
            $

            其中，$h(1) = -Prices(1)$，$g(1) = 0$

        - 【TODO】
          - 从以上递推式可以看出，任意交易日的结果只取决于前一个交易日，可以简化记忆，每次计算时滚动更新两个变量来记录前一交易日的有头寸和无头寸利润即可

      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【贪心法】
      - 分析
        - 【TODO】
      - 步骤
        1. 设置两个变量，一个记录最低价格，一个记录最高利润
        1. 遍历数组的每个元素：
           1. 检查是否低于最低价格：
              - 是：更新最低价格
              - 否：与最低价格相减，检查差值是否高于最高利润：
                - 是：更新最高利润
                - 否：继续
        1. 返回最高利润
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [53.最大子序和](questions/wrong/53.最大子序和.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 数组中的最大子序列是以数组中的某两个小标分隔出来的连续序列，因为一般正向遍历，当遍历到子序列尾的时候就已经把整个子序列遍历完，所以以序列尾标作为锚，即定义$f(i)$为以第$i$个元素结尾的子序列和
      - 整个数组的最大子序和即为：$max\{f(i) | i \in [0,n) \}$
      - 对于任意的$f(i)$，其值取决于$f(i-1)$和第$i$个元素：
        $f(i) = max(f(i-1) + a_i, a_i)$
        - $f(i-1)$大于0时：以第i个元素为结尾的子序列和要取得最大值，必然包含以i-1为结尾的子序列
        - $f(i-1)$小于0时：以第i个元素为结尾的子序列和要取得最大值，必不能包含以i-1为结尾的子序列
    - 【TODO】
      - 任意$f(i)$的计算只取决于前一个$f(i-1)$，而最终结果以及每个$f(i)$是否有可能成为最大子序和都只取决于之前遍历到的最大的$f(i)$
      - 因此只需要两个变量即可简化记忆，一个记录前一个$f(i)$，一个记录之前遍历到的最大的$f(i)$，并在遍历过程中不断更新这两个记录值即可
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [198.打家劫舍](questions/optimizable/198.打家劫舍.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
          - 为了得到最大值，偷家序列中的“连续不偷子序列”不可能大于等于3，即不可能连续3家以上选择不偷
          - 因此对任一房屋i来说：
            - 选择偷：则i-2房屋也要一起偷，否则无法得到最大值
            - 选择不偷：则i-1的房屋必须偷，否则无法得到最大值
          - 所以任意房屋i的最大偷窃金额取决于前两个房屋：

            $f(i) = max\left\{\begin{array}{l}
            f(i-2) + a_i \\
            f(i-1)
            \end{array}\right.$

          - 则$f(n)$，即n个房屋的最大偷窃金额即最终结果
        - 【TODO】
          - 因为任意$f(i)$的计算只取决于前两个房屋，所以可以简化记忆为两个变量，分别记录前两个房屋，并在遍历过程中滚动更新即可
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [204.计数质数](questions/wrong/204.计数质数.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 质数的定义是因子只有1和自身，那么如果某数不是质数，则它必然可以因式分解为某几个质数，即它必然是某几个质数的倍数
      - 因此，只有知道某个数x是质数，则必然知道2x，3x等不是质数
      - 而对于某个数是否为质数，我们只能通过其有没有自身以外的质因子判断，而这些质因子若存在，则必然比他小
      - 这意味着我们可以从最小的已知质数开始计算每个质数的倍数并做标记，当遍历到某个更大的数时，该数若有标记就是合数，因为之前遍历发现了它的质因子；若无标记则是质数，因为它没有比它更小的质因子
  - 解法
    - 【埃氏筛】
      - 分析
        - 【TODO】
          - 对于遍历到的某个质数x，虽然他的倍数如2x，3x等必然是合数，但其中有部分倍数即$\{n \cdot x | n \in [0, x) \}$是已经被小于x的质数标记过的，不需要由质数x来冗余标记
          - 所以对任意质数x，他的倍数的计算可以直接从它的平方开始，即$x \cdot x$、$x(x+1)$
      - 步骤
        1. 构建长度为n的状态数组，小于n的所有数的状态都初始化为true，即先认为所有数都是质数
        1. 从2这个已知质数开始遍历小于n的所有数，令i为迭代变量：
           1. 检查状态数组中以i为下标的状态：
              - false：继续遍历
              - true：
                1. 累加质数数量
                1. 检查$i^2$是否小于n：
                   - 否：继续遍历
                   - 是：
                     1. 从$i^2$开始遍历，令j为迭代变量，每次迭代步长为i：
                        1. 将状态数组以j为下标的状态置为false
        1. 返回质数数量累加值
      - 复杂度
        - 时间：O($n\log_2\log_2n$)
        - 空间：O(n)
    - 【线性筛】
      - 分析
        - 【TODO】
          - 埃氏筛是有冗余标记的。任意合数有几个质因子就会被埃氏筛冗余标记几次，导致时间复杂度无法达到O(n)
          - TODO
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(n)
        - 空间：O(n)

- [326.3-的幂](questions/wrong/326.3-的幂.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 步骤
        1. 循环检查n是否大于0：
           - 是：检查n是否能整除3：
             - 是：计算n除以3地商，并将商结果覆盖n
             - 否：跳出循环
           - 否：跳出循环
        1. 返回n是否等于1的判定结果
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【TODO】
      - 分析
        - 【TODO】
          - 32位整数中最大的3的幂为$3^19$，只要n是$3^19$的约数，那么n就必定是3的幂，否则就必定不是3的幂
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [191.位-1-的个数](questions/optimizable/191.位-1-的个数.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
          - 对于一个比较短的位串，我们是可以直接看出有几个1的。即一个比较小的k，k-位串中1的数量可以直接看出来。则一个较大的位串可以分成好几个小段，直接累加每段中1的数量
          - 那么我们可以构建一个k-位串表，以k-位串所有可能值作为下标或者说映射的键，则表上有$2^k$个元素，每个元素值都是其下标的二进制表示中1的数量
          - n每次都与全是1的k-位串做位与运算，可以得到最低k位的二进制表示，该位串作为下标直接查表即可得到n最低k位中有几个1，统计后将n向右位移即可继续做同样的运算
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【Brian Kernighan】
      - 分析
        - 【TODO】
          - 只要不断右移并统计最低位的1的个数，或者用$2^i$来匹配并统计即可
          - 但是注意$n \& (n-1)$的运算结果恰好就是把n最低为的1置0，可以利用该性质加速检查过程
          - 不断将$n \& (n-1)$的运算结果覆盖n，直到n=0，期间计算了多少次，n中就有多少个1
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【平行法】
      - 分析
        - 【TODO】
          - 将位串每相邻的两位分成一组，每组的两位相加并将运算结果的二进制表示覆盖本组，此时每组的两个位合起来表示的是本组的1的数量
          - 将整个位串每相邻的四位分成一组，每组的四位相加并将运算结果的二进制表示覆盖本组，此时每组的四个位合起来表示的是本组的1的数量
          - 不断扩大每组的位数并重复上述步骤，直到所有位分作一组并计算出相加结果即可得到整个位串的1的数量
      - 算法

        ```rust
        fn hamming_weight(mut n: u32) -> usize {
            n = ((n & 0xaaaaaaaa) >> 1) + (n & 0x55555555);
            n = ((n & 0xcccccccc) >> 2) + (n & 0x33333333);
            n = ((n & 0xf0f0f0f0) >> 4) + (n & 0x0f0f0f0f);
            n = ((n & 0xff00ff00) >> 8) + (n & 0x00ff00ff);
            n = ((n & 0xffff0000) >> 16) + (n & 0x0000ffff);
            n as usize
        }
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [461.汉明距离](questions/accepted/461.汉明距离.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 异或运算识别出两个位串有哪些位不同，这些位都会被置为1
      - 计算异或结果中1的个数即可得到汉明距离
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [190.颠倒二进制位](questions/wrong/190.颠倒二进制位.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【二分旋转】
      - 分析
        - 【TODO】
          - 将32位串分成两半进行旋转，即前16位和后16位整体交换
          - 再分别对两串16位串分成两半8位串继续旋转
          - 以此类推直到分割成两个1位串并旋转完
      - 算法

        ```rust
        fn reverse_bits(mut x: u32) -> usize {
            x = (x >> 16) | (x << 16);
            x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8);
            x = ((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4);
            x = ((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2);
            x = ((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1);
            x as usize
        }
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

    - 【分治】
      - 分析
        - 【TODO】
          - 将位串每相邻的两位分成一组，每组的两位交换
          - 再将整个位串每相邻的四位分成一组，每组的高两位和低两位整体交换
          - 如上不断扩大每组的位数并重复上述步骤，直到所有位分作一组并把高16位和低16位整体交换
      - 算法

        ```rust
        fn reverse_bits(mut x: u32) -> usize {
            x = ((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1);
            x = ((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2);
            x = ((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4);
            x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8);
            x = ((x & 0xffff0000) >> 16) | ((x & 0x0000ffff) << 16);
            x as usize
        }
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [118.杨辉三角](questions/accepted/118.杨辉三角.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 杨辉三角在计算机的按行存储的模型下，会被左对齐，三角左边的1在一列上
      - 在计算机存储模型视角下，杨辉三角每个元素(i,j)都是上一行的同列元素(i-1, j)和前列元素(i-1, j-1)之和
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [20.有效的括号](questions/accepted/20.有效的括号.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 一个有效的括号表达式，最底层的嵌套的括号对，其开括号一定比上层开括号出现的最晚，但其闭括号却比上层闭括号出现的最早，这很适合栈的出入原则——后进先出
      - 遇到开括号入栈，遇到闭括号，就出栈检查开括号是否与该闭括号匹配
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [268.丢失的数字](questions/wrong/268.丢失的数字.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 数组有n个数，每个数都不同，而值域是[0, n]的n+1个数，意味着数组只缺失了一个数字
  - 解法
    - 【TODO】
      - 分析
        - 【数学：数列求和】
          - 这是一个缺失了一个数字的等差数列，可以计算该等差数列和，然后再计算数组和，两个和相减的差就是缺失的数字
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【TODO】
      - 分析
        - 【数学：异或位运算】
          - 数组的每个数字都是唯一的，而且只缺失了值域中的一个数字，意味着如果在数组后面把值域所有数字都添加上去，则缺失的数字唯一，而其他数字全都重复两次
          - 对于一个数组只有一个数字唯一，其他数字都重复两次，可以使用异或位运算的性质求解
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

## 哈希

最优解为哈希的问题一般有如下特性：

- 【集合环境依赖】集合中某个元素的条件判定与集合内其他元素或其他集合有关

- [1.两数之和](questions/accepted/1.两数之和.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：
    - 【集合环境依赖】
      - 数组内某元素是不是两数和组成部分的判定，取决于数组内其他元素的状态，具体来说就是有无一个元素与该元素的和恰好是目标值
  - 解法
    - 【哈希】Time=O(n), Space=O(n)
      - 构建一个以元素值为键，元素值下标为值的哈希表
      - 遍历每个元素，计算目标值减去元素的差值是否在表中：
        - 若存在，则返回该键的值与当前元素下标值组成的二元组
        - 若不存在，则插入以元素值为键，元素下标为值的键值对入表

- [217.存在重复元素](questions/accepted/217.存在重复元素.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：
    - 【集合环境依赖】
      - 一个数组是否存在重复元素的判定，可以解释为数组中各个元素是否重复的判定
      - 数组中某元素是否重复的判定，取决于数组内其他元素的状态，具体来说就是其他元素的值有没有和该元素相同的
  - 解法
    - 【哈希】Time=O(n), Space=O(n)
      - 对每个元素，将其插入集合中，若发现集合中已存在，则存在重复元素

- [242.有效的字母异位词](questions/optimizable/242.有效的字母异位词.rs)
  - 条件
    - 【ASCII字符串】
  - 分析：
    - 【集合环境依赖】
      - 两个字符串是否为字母异位词的判定，可以解释为一个串中每个字符值出现次数是否与另一串等同
      - 一个串中某字符的值是否在交集内的判定，取决于该数组内其他元素的状态以及另一数组内元素的状态，具体来说就是当前数组内的同值元素和另一数组内的同值元素出现次数
  - 解法
    - 【哈希】Time=O(n), Space=O($\Sigma$)
      - 构建一个以字符值为键，字符出现次数为值的哈希表
      - 遍历其中一个字符串，将字符出现频次统计入哈希表
      - 遍历另一个字符串：
        - 字符值不在哈希表中，则不是异位词，返回结果
        - 字符值在哈希表中则对应的出现次数-1，若-1后为0，则移除该键值对
      - 遍历结束后，若哈希表为空，则为异位词

- [350.两个数组的交集-ii](questions/accepted/350.两个数组的交集-ii.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析
    - 【集合环境依赖】
      - 一个数组某元素是否在交集内的判定，取决于该数组内其他元素的状态以及另一数组内元素的状态，具体来说就是当前数组内的同值元素和另一数组内的同值元素出现次数
  - 解法
    - 【哈希】Time=O(m + n), Space=O( min(m, n) )
      - 使用以元素值为键，出现次数为值的哈希表
      - 遍历较短的数组，记录每个元素的出现次数
      - 遍历另一数组，对存在于哈希表中的元素，将元素记录到返回结果中，并将次数-1。若次数-1后为0，则从哈希表移除该元素

- [387.字符串中的第一个唯一字符](questions/accepted/387.字符串中的第一个唯一字符.rs)
  - 条件
    - 【ASCII字符串】
  - 分析
    - 【集合环境依赖】
      - 字符串中的某个字符是否唯一的判定，取决于字符串内其他字符的状态，具体来说就是其他字符有没有和该字符相同的
  - 解法
    - 【哈希】Time=O(n), Space=O($\Sigma$)
      - 构建一个以元素值为键，元素出现次数为值的哈希表
      - 遍历字符串，统计元素出现次数到哈希表中
      - 遍历哈希表，遇到次数为1的元素记录就返回结果

### 哈希+状态位串

- [36.有效的数独](questions/accepted/36.有效的数独.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析
    - 【集合环境依赖】
      - 数独是否有效的判定，可以解释为数独矩阵每个数字是否有效的判定
      - 数度矩阵每个元素是否有效的判定，可解释为该元素在三个集合中是否有效的判定
      - 每个元素在对应的三个集合中是否有效的判定，取决于三个集合内部其他元素的状态。具体来说该元素值对应的列集合、行集合和宫集合的其他元素有无重复值
    - 【定长布尔状态集】
      - 因为三个元素状态集只需要记录元素是否存在即可，可解释为布尔值
      - 又因为元素的键值就是元素值本身而其值域只有1-9，是固定且较小的值域
      - 所以可以用一个长度合适的位串来记录元素状态，元素键值映射对应的位是0还是1来记录元素是否存在
  - 解法
    - 【哈希】+【布尔串】Time=O(a * a), Space=O(a + a + a)
      - 构建三个哈希表：
        - 行哈希表：以行号为键，以位数大于等于列数a的位串为值
        - 列哈希表：以列号为键，以位数大于等于行数a的位串为值
        - 宫哈希表：以宫号为键，以位数大于等于宫数a的位串为值
      - 遍历矩阵每个元素(i,j)：
        - 将1按位右移，偏移量等于该元素值，所得结果作为元素模式
        - 元素模式与行哈希表第i行对应的位串按位与操作：
          - 结果==0：将元素模式以按位或操作的方式更新到行哈希表第i行对应的位串
          - 结果!=0：判别为无效数独并返回结果
        - 元素模式与列哈希表第j列对应的位串按位与操作：
          - 结果==0：将元素模式以按位或操作的方式更新到列哈希表第j列对应的位串
          - 结果!=0：判别为无效数独并返回结果
        - 元素模式与宫哈希表第(i/3+j/3)宫对应的位串按位与操作：
          - 结果==0：将元素模式以按位或操作的方式更新到宫哈希表第(i/3+j/3)宫对应的位串
          - 结果!=0：判别为无效数独并返回结果

## 双指针

- [26.删除有序数组中的重复项](questions/accepted/26.删除有序数组中的重复项.rs)：
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
    - 【有序】因为数组是有序的，重复项必定相邻
  - 分析：TODO
  - 解法
    - 【双指针】Time=O(n), Space=O(1)
      - 将数组分割成两部分，前一部分不重复，后一部分可能重复
      - 左指针指向不重复数组的末端，左指针之前没有重复，之后可能存在重复
      - 右指针向前探索不断寻找左指针之前没有的值，然后将其加入左指针之前的数组，左指针则配合着前进一步来扩大不重复数组范围

- [125.验证回文串](questions/accepted/125.验证回文串.rs)
  - 条件
    - 【ASCII字符串】
  - 分析：TODO
  - 解法
    - 【双指针】Time=O($log_2n$), Space=O(1)
      1. 左指针指向字符串头，右指针指向字符串尾，左右指针相向移动，步长为1
      1. 左右指针都跳过非字母的字符
      1. 检查左右指针指向的字符值是否相等
         - 若相等，左右指针移动一步，回到(2)
         - 若不等，则不是回文串，返回结果
      1. 重复(2)(3)直到左指针和右指针相等或交错

- [283.移动零](questions/accepted/283.移动零.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：TODO
  - 解法
    - 【双指针】Time=O(n), Space=O(1)
      - 将数组分割成两部分，前一部分没有0，后一部分可能有0
      - 左指针指向非0数组的末端，左指针之前没有0，之后可能存在0
      - 右指针向前探索不断寻找非0值，然后将其加入左指针之前的数组，左指针则配合着前进一步来扩大不重复数组范围

- [344.反转字符串](questions/accepted/344.反转字符串.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：TODO
  - 解法
    - 【双指针】Time=O(n), Space=O(1)
      - 左指针从数组头开始，右指针从数组尾开始
      - 交换两个指针所指的值
      - 左指针向尾移动一步，右指针向头移动一步

## 动态规划

题目带有如下性质时，一般可以用动态规划求最优解：

- 【递归求最值】含有递归性质，且题目任务是求最值

### 贪心法

- [122.买卖股票的最佳时机-ii](questions/optimizable/122.买卖股票的最佳时机-ii.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：TODO
  - 解法
    - 【贪心法】Time=O(n), Space=O(1)
      - 对数组每个元素检查是否比下一元素小
      - 若是，则将二者的差累加到返回值
