# 二分查找

二分查找算法正确性证明如下：

循环不变式：目标值$T$如果存在与数组$A$中，则必然存在于区域$A[l .. r]$内

- 初始化：初始时$l=0$，$r=len(A)$，计算区域覆盖整个数组，此时循环不变式必然是成立的
- 保持：循环时，有如下操作，循环不变式依然成立：
  - $A_{mid} = T$：找到目标值，直接返回结果
  - $A_{mid} < T$：目标值不可能在中值左侧区域$[l .. mid]$内，只可能在右侧区域$[mid+1 .. r]$内，令$l = mid+1$。循环不变式依旧成立
  - $A_{mid} > T$：目标值不可能在中值右侧区域$[mid .. r]$内，只可能在左侧区域$[l .. mid-1]$内，令$r = mid-1$。循环不变式依旧成立
- 终止：$l > r$时停机，目标值不在数组内

## 二分查找最先出现

二分查找的变体，结合查找目的，每次二分查找时的三种情况中，等于目标值的情况有所不同：

- $A_{mid} = T$：找到目标值，则目标值首次出现的位置不可能在中值右侧区域$[mid .. r]$内，只可能在当前的中值位置，或者，左侧区域$[l .. mid-1]$内，因此令$r = mid-1$

即遇到等于目标值的元素也要像大于目标值那样，向左移动：

- $A_{mid} < T$：右移，令$l = mid+1$
- $A_{mid} \ge T$：左移，令$r = mid-1$

这个算法的正确性证明：

循环不变式：目标值$T$如果存在与数组$A$中，则目标值第一次出现的位置要么被记录为$I$，要么存在于区域$A[l .. r]$内

- 初始化：初始时$l=0$，$r=len(A)$，计算区域覆盖整个数组，此时循环不变式必然是成立的
- 保持：循环时，有如下操作，循环不变式依然成立：
  - $A_{mid} = T$：找到目标值，则目标值首次出现的位置不可能在中值右侧区域$[mid .. r]$内，只可能在当前的中值位置，或者，左侧区域$[l .. mid-1]$内，因此令$I = mid$，令$r = mid-1$。循环不变式依旧成立
  - $A_{mid} < T$：目标值首次出现的位置不可能在中值左侧区域$[l .. mid]$内，只可能在右侧区域$[mid+1 .. r]$内，令$l = mid+1$。循环不变式依旧成立
  - $A_{mid} > T$：目标值首次出现的位置不可能在中值右侧区域$[mid .. r]$内，只可能在左侧区域$[l .. mid-1]$内，令$r = mid-1$。循环不变式依旧成立
- 终止：$l > r$时停机：
  - $I$没有赋值：目标值不在数组内
  - $I$有赋值：$I$就是目标值首次出现位置

- [278.第一个错误的版本](questions/wrong/278.第一个错误的版本.rs)
  - 条件
    - 【数组】
    - 【有序】
  - 分析
    - 【TODO】
  - 解法
    - 【二分查找（改）】
      - 分析
        - 【TODO】
      - 步骤
        1. 从中间元素开始二分查找：
           1. API返回false则向后查找
           1. API返回true则向前查找
        1. 全部元素查找完后，返回二分查找的左边界
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

## 二分查找最后出现

二分查找的变体，结合查找目的，每次二分查找时的三种情况中，等于目标值的情况有所不同：

- $A_{mid} = T$：找到目标值，则目标值最后出现的位置不可能在中值左侧区域$[l .. mid]$内，只可能在当前的中值位置，或者，右侧区域$[mid+1 .. r]$内，因此令$l = mid+1$

即遇到等于目标值的元素也要像小于目标值那样，向右移动：

- $A_{mid} \le T$：右移，令$l = mid+1$
- $A_{mid} > T$：左移，令$r = mid-1$

这个算法的正确性证明：

循环不变式：目标值$T$如果存在与数组$A$中，则目标值第一次出现的位置要么被记录为$I$，要么存在于区域$A[l .. r]$内

- 初始化：初始时$l=0$，$r=len(A)$，计算区域覆盖整个数组，此时循环不变式必然是成立的
- 保持：循环时，有如下操作，循环不变式依然成立：
  - $A_{mid} = T$：找到目标值，则目标值最后出现的位置不可能在中值左侧区域$[l .. mid]$内，只可能在当前的中值位置，或者，右侧区域$[mid+1 .. r]$内，因此令$I = mid$，令$r = mid-1$。循环不变式依旧成立
  - $A_{mid} < T$：目标值最后出现的位置不可能在中值左侧区域$[l .. mid]$内，只可能在右侧区域$[mid+1 .. r]$内，令$l = mid+1$。循环不变式依旧成立
  - $A_{mid} > T$：目标值最后出现的位置不可能在中值右侧区域$[mid .. r]$内，只可能在左侧区域$[l .. mid-1]$内，令$r = mid-1$。循环不变式依旧成立
- 终止：$l > r$时停机：
  - $I$没有赋值：目标值不在数组内
  - $I$有赋值：$I$就是目标值最后出现位置

- [34.在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)（[我的实现](questions/wrong/34.在排序数组中查找元素的第一个和最后一个位置.rs)）
  - 条件
    - 【数组】
    - 【有序】
  - 分析
    - 【TODO】
      - 有序数组中查找，可以使用二分查找的办法，但要对中值等于目标值的情况做不同处理：
        - $A_{mid} == T$：
          - 最先出现位置：**向右**移动。该情况意味着目标值最先出现的位置不可能在中值的右侧（因为右侧的值比中值出现的还晚），所以只可能是中值或者在中值左侧（因为左侧的值比中值出现的更早），因此和中值大于目标值的情况一样向右移动
          - 最后出现位置：**向左**移动。该情况意味着目标值最后出现的位置不可能在中值的左侧（因为左侧的值比中值出现的还早），所以只可能是中值或者在中值右侧（因为右侧的值比中值出现的更晚），因此和中值小于目标值的情况一样向左移动
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
