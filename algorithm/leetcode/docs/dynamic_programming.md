# 动态规划

题目带有如下性质时，一般可以用动态规划求最优解：

- 【递归求最值】含有递归性质，且题目任务是求最值

- [322.零钱兑换](https://leetcode-cn.com/problems/coin-change/)（[我的实现](questions/accepted/322.零钱兑换.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【最优子结构】
      - 任一金额的最小钞票数量，都可以通过计算更小金额的最小钞票数量来求解，而计算哪些更小的金额则取决于钞票面额的集合。比如10元的金额在钞票面额集合为{1元，2元，5元}时，可以通过计算金额为10-1=9元、10-2=8元、10-5=5元，这些通过减去1张钞票面额计算出来的更小金额，都可以直接逆计算即加上被减去的钞票面额得到10元，换言之，这些金额都可以加上一张有被减去的面额的钞票来凑齐10元：
        - 9元：9元本身需要3张钞票（2张2元，1张5元），再加上一张1元钞票就可以凑齐10元，总共4张
        - 8元：8元本身需要3张钞票（1张1元，1张2元，1张5元），再加上一张2元钞票就可以凑齐10元，总共4张
        - 5元：5元本身需要1张钞票（1张5元），再加上一张5元钞票就可以凑齐10元，总共2张
      - 令$F(i)$表示凑齐$i$元需要的最小钞票数量，令$c_j$为钞票面额，令$n$为钞票面额集合大小，则递推式如下：

        $F(i)=\underset{j=1..n}{min}F(i-c_j)+1=min\left\{\begin{array}{l}
        F(i-c_1)+1 \\
        F(i-c_2)+1 \\
        ... \\
        F(i-c_n)+1 \\
        \end{array}\right.$

    - 【记忆化搜索】
      - 上述递推式在计算时会重复计算许多中间结果，因此从$F(0)$、$F(1)$开始算起并记录中间结果以在后续计算中使用，可以节省大量计算时间

  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [62.不同路径](https://leetcode-cn.com/problems/unique-paths/)（[我的实现](questions/wrong/62.不同路径.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【动态规划】
      - 分析
        - 【TODO】
          - 对于矩阵任一格$(i,j)$，只可能从$(i,j-1)$向下走一步、或从$(i-1,j)$向右走一步过来，因此到达$(i,j)$的路径数量是到达$(i-1,j)$和$(i,j-1)$两格的路径总和，而题目的解是到达$(m,n)$的路径数量
          - 令$DP_{ij}$为到达某格$(i,j)$的路径数量，则有$DP_{ij} = DP{i-1,j} + DP{i,j-1}$
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【排列组合】
      - 分析
        - 【TODO】
          - 从左上角移动到右下角，无论如何移动都是至少要移动$(m-1)+(n-1)=m+n-2$步，其中必有$m-1$次向下移动和$n-1$次向右移动
          - 不同的路径可以看作是$m-1$次向下移动和$n-1$次向右移动的排列组合，如果按照直觉思维即“第一次移动有两个分支即下或右，然后第二次移动在第一次移动的两个分支基础上再继续分裂下或右的分支，...”去思考会把问题复杂化
          - 这个排列组合可以看作是一个大小为$m+n-2$的移动集合，从中选出$m-1$个移动作为向下移动（或等价地，从中选出$n-1$个移动作为向右移动），注意这是组合而不是排列，因为选择的次序无关。先选择第i次移动向下、后选择第j次移动向右，和先选第j次移动向右、后选择第i次行动向下；这二者的次序不影响结果
          - 因此该问题的计算公式或者说数学模型是：

            $
            C(m+n-2, m-1)=\left(\begin{array}{c}m+n-2\\m-1\end{array}\right)=\frac{(m+n-2)!}{(m-1)!(n-1)!}
            $

            计算机是用循环乘来计算阶乘的，计算上式时会比较麻烦：

            - 如果分子和分母的两个因子单独循环计算出结果，然后分母因子相乘再被分子除，很容易溢出。阶乘的结果往往比较大
            - 如果控制在一个循环里，每次循环都计算各部分的一个阶，然后立刻计算相除结果并暂存，则循环条件会因为分子分母各自循环条件的差异而变得不好写：分母要循环$m+n-2$次，分子的两个因子分别要循环$m-1$次和$n-1$次该公式

            所以为了方便计算机计算排列组合，上式一般会整理成如下形式，使得各部分循环条件统一循环m次：

            $
            C(m+n-2, m-1)=\frac{(m+n-2)(m+n-3)...(n+1)n}{(m-1)!}
            $

          - 计算该公式要循环m次，所以复杂度是O(m)。但因为选择向下或者选择向右都是等价问题，所以m和n是可以互换的，可以选择行数和列数较小的那个作为循环次数，使得复杂度为O(min(m,n))

      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [70.爬楼梯](questions/wrong/70.爬楼梯.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【可分治】问题的解可由子问题的解组合而来
  - 解法
    - 【动态规划】
      - 分析
        - 【TODO】
      - 步骤
        1. 检查n是否小于等于1：
           - 是：返回1
           - 否：
             1. 递归计算n-1阶的结果
             1. 递归计算n-2阶的结果
             1. 将两个递归结果相加并返回
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【动态规划+记忆化搜索】+【记忆简化】
      - 分析
        - 【TODO】
      - 步骤
        1. 设置变量v0=1，表示爬0级台阶有1种方法；设置变量v1=1，表示爬1级台阶有1种方法
        1. 要爬n级台阶则迭代n-2次，每次迭代：
           1. 设置临时变量，值等于v0+v1
           1. 将v1的值赋给v0
           1. 将临时变量的值赋给v1
        1. 返回v0+v1的和
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【动态规划+数学建模：矩阵快速幂】
      - 分析
        - 【齐次线性递推式】
          - 动态规划递推式为：$f(n) = f(n-1) + f(n-2)$，这是齐次线性方程，可以直接转换为矩阵递推式：

            $
            \begin{bmatrix}
            f(n+1) \\
            f(n)
            \end{bmatrix} = \begin{bmatrix}
            f(n) + f(n-1) \\
            f(n)
            \end{bmatrix} = \begin{bmatrix}
            1 & 1 \\
            1 & 0
            \end{bmatrix} \begin{bmatrix}
            f(n) \\
            f(n-1)
            \end{bmatrix} = \begin{bmatrix}
            1 & 1 \\
            1 & 0
            \end{bmatrix}^n \begin{bmatrix}
            f(1) \\
            f(0)
            \end{bmatrix}
            $

          - 根据以上递推式结果，可以使用快速幂来求系数矩阵，从而求出$f(n)$，即爬n级有多少种方法的解

      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【动态规划+数学建模：通项公式】
      - 分析
        - 【TODO】
          - 对任意的$a_{n+2} = pa_{n+1} + qa_n$，都可以令$a_n = x^n$代入求得$x^2 = px + q$。该性质对$f(n) = f(n-1) + f(n-2)$也是成立的
          - 令$f(n) = x^n$，可得$x^2 = x + 1$，求解得$x_1 = \frac{1 + \sqrt{5}}{2}$，$x_2 = \frac{1 - \sqrt{5}}{2}$
          - 设通解为$f(n) = c_1 x^n_{1} + c_2 x^n_{2}$，代入递推初始条件$f(0) = 1$和$f(1) = 1$，可得$c_1 = \frac{1}{\sqrt{5}}$，$c_2 = -\frac{1}{\sqrt{5}}$
          - 则$f(n) = \frac{1}{\sqrt{5}} \left[ \left( \frac{1 + \sqrt{5}}{2} \right)^n - \left( \frac{1 - \sqrt{5}}{2} \right)^n \right]$
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [53.最大子序和](questions/wrong/53.最大子序和.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 数组中的最大子序列是以数组中的某两个小标分隔出来的连续序列，因为一般正向遍历，当遍历到子序列尾的时候就已经把整个子序列遍历完，所以以序列尾标作为锚，即定义$f(i)$为以第$i$个元素结尾的子序列和
      - 整个数组的最大子序和即为：$max\{f(i) | i \in [0,n) \}$
      - 对于任意的$f(i)$，其值取决于$f(i-1)$和第$i$个元素：
        $f(i) = max(f(i-1) + a_i, a_i)$
        - $f(i-1)$大于0时：以第i个元素为结尾的子序列和要取得最大值，必然包含以i-1为结尾的子序列
        - $f(i-1)$小于0时：以第i个元素为结尾的子序列和要取得最大值，必不能包含以i-1为结尾的子序列
    - 【TODO】
      - 任意$f(i)$的计算只取决于前一个$f(i-1)$，而最终结果以及每个$f(i)$是否有可能成为最大子序和都只取决于之前遍历到的最大的$f(i)$
      - 因此只需要两个变量即可简化记忆，一个记录前一个$f(i)$，一个记录之前遍历到的最大的$f(i)$，并在遍历过程中不断更新这两个记录值即可
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [198.打家劫舍](questions/optimizable/198.打家劫舍.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
          - 为了得到最大值，偷家序列中的“连续不偷子序列”不可能大于等于3，即不可能连续3家以上选择不偷
          - 因此对任一房屋i来说：
            - 选择偷：则i-2房屋也要一起偷，否则无法得到最大值
            - 选择不偷：则i-1的房屋必须偷，否则无法得到最大值
          - 所以任意房屋i的最大偷窃金额取决于前两个房屋：

            $f(i) = max\left\{\begin{array}{l}
            f(i-2) + a_i \\
            f(i-1)
            \end{array}\right.$

          - 则$f(n)$，即n个房屋的最大偷窃金额即最终结果
        - 【TODO】
          - 因为任意$f(i)$的计算只取决于前两个房屋，所以可以简化记忆为两个变量，分别记录前两个房屋，并在遍历过程中滚动更新即可
      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

## 贪心法

- [122.买卖股票的最佳时机-ii](questions/optimizable/122.买卖股票的最佳时机-ii.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：TODO
  - 解法
    - 【贪心法】Time=O(n), Space=O(1)
      - 对数组每个元素检查是否比下一元素小
      - 若是，则将二者的差累加到返回值

- [55.跳跃游戏](https://leetcode-cn.com/problems/jump-game/)（[我的实现](questions/wrong/55.跳跃游戏.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【动态规划】
      - 分析
        - 【TODO】
          - 当跳跃可以越过某个下标时，此时跳跃策略只有两种选择：
            - 直接越过该下标
            - 在该下标重新跳跃

            只有从该下标重新跳跃所能到达距离比直接越过还要短时，我们才会选择直接越过该下标，对于越过下标这个跳跃策略而言：

            - 从前一下标$i-1$越过当前下标$i$：前一下标$i-1$的最远距离等于下标对应值
            - 从比$i-1$更早的下标越过当前下标$i$：前一下标$i-1$的最远距离等于更前的下标$i-2, i-3, ...$等的最远距离，此时$i-1$的最远距离意味着$i-1$之前的某个下标起跳到达的最远距离

            当下标$i$选择被越过时，也意味着它之前的所有下标都可达，且从他之前的某个下标起跳可以比从它自身起跳更远，所以它的最远距离就是前一下标的最远距离，而前一下标的最远距离同样是要么以自身起跳、要么从更前的某个下标起跳

          - 令$DP_i$表示跳跃经过下标$i$时能跳到的最远的下标，则有如下递推方程：

            $DP_i = max\left\{\begin{array}{l}
            a_i \\
            DP_{i-1} \\
            \end{array}\right.$

          - 当某一下标的最远距离计算出来可以到达最后一个下标时就可以返回结果，或者某次遍历发现前一下标的最远距离无法到达当前下标时结束计算并返回失败的结果
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【贪心法】
      - 分析
        - 【直觉切入】
          - 问题解答只需要遍历所有下标，当发现某个下标起跳时能否达到最末尾就可以确定答案。而某下标是否能遍历，取决于之前某个下标起跳能否到达该下标
          - 因此设置动态变量在每次遍历时记录当前遍历到的下标起跳最远能到达哪里，并在该最远跳跃范围内继续遍历。直到最远跳跃范围无法继续更新，而范围内又没有下标能跳跃到最末尾时返回失败
        - 【动态规划切入：记忆简化】
          - 动态规划的分析中，可以发现，我们需要记忆的只有前一下标的最远距离，它意味着当前下标$i$之前某个下标起跳的最远距离
          - 因此我们只需在遍历中不断的在自身起跳和之前起跳之间选择最大值，并将最大值更新到之前起跳的记忆变量中，就可以在下一次遍历继续比对并更新，直到某次遍历中发现能到达最远下标
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [121.买卖股票的最佳时机](questions/wrong/121.买卖股票的最佳时机.rs)
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【动态规划+记忆化搜索】+【记忆简化】
      - 分析
        - 【TODO】
          - 对于任意交易日来说，当日只有两种情况：
            - 无头寸：无头寸时又有两种情况：
              - 今日卖出：该情况下，利润就是前一交易日的“有头寸”的利润加上今日卖出所得的利润
              - 今日无交易：这意味着前一交易日就没有头寸。该情况下，利润就是前一交易日的“无头寸”的利润
            - 有头寸：有头寸时又有两种情况：
              - 今日买入：该情况下，利润就是当日股票价格的负数，因为买入股票意味着账面暂时损失了买入价格，在卖出之前，利润都是负的
              - 今日无交易：这意味着前一交易日就有头寸。该情况下，利润就是前一交易日的“有头寸”的利润
          - 因此对于任意交易日来说，当日有头寸和无头寸的利润就是：
            - 无头寸利润 = max(今日卖出后无头寸, 今日无交易也无头寸) = max(前一交易日有头寸+今日卖出价格, 前一交易日无头寸利润)
            - 有头寸利润 = max(今日买入后有头寸, 今日无交易但有头寸) = max(-1*今日买入价格, 前一交易日有头寸利润)
          - 令$h(n)$表示第n交易日有头寸利润，$g(n)$表示第n交易日无头寸利润，则n个交易日后的最大利润$f(n)$：

            $
            f(n) = max\left\{\begin{array}{l}
            h(n) = max(-Prices(n), h(n-1)) \\
            g(n) = max(h(n-1)+Prices(n), g(n-1))\\
            \end{array}\right.
            $

            其中，$h(1) = -Prices(1)$，$g(1) = 0$

        - 【TODO】
          - 从以上递推式可以看出，任意交易日的结果只取决于前一个交易日，可以简化记忆，每次计算时滚动更新两个变量来记录前一交易日的有头寸和无头寸利润即可

      - 步骤
        1. TODO
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【贪心法】
      - 分析
        - 【TODO】
      - 步骤
        1. 设置两个变量，一个记录最低价格，一个记录最高利润
        1. 遍历数组的每个元素：
           1. 检查是否低于最低价格：
              - 是：更新最低价格
              - 否：与最低价格相减，检查差值是否高于最高利润：
                - 是：更新最高利润
                - 否：继续
        1. 返回最高利润
      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

- [5.最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)（[我的实现](questions/wrong/5.最长回文子串.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
  - 解法
    - 【动态规划】
      - 分析
        - 【TODO】
          - 回文串去掉头尾之后依旧是回文串，换言之，一个串是不是回文串取决于头尾是否相等以及去掉头尾后是不是回文串
          - 因此一个串是不是回文取决于一个更小规模的子问题的解，即可以分解为子问题
          - 综上，令$P(i,j)$表达串从i到j的子串是否为回文，$s_i$表达串的第i个字符，则转移方程为：

            $
            P(i, j) = P(i+1, j-1) \wedge (s_i == s_j)
            $

            边界条件为：

            $
            \left\{\begin{array}{l}
            P(i, i) = true \\
            P(i, i+1) = s_i == s_{i+1} \\
            \end{array}\right.
            $

          - 实现时为了避免重复计算，可以从最短长度即长度为1开始枚举回文子串，每次枚举都从首个字符开始遍历，检查以该字符开始的有指定长度的子串是否是回文

      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

    - 【贪心法】
      - 分析
        - 可以从两个角度来分析：
          - 【TODO】从直觉角度来分析：
            - 回文串都有回文中心并从回文中心向两边对称扩展
            - 因此可以遍历串的每个字符，以每个字符为回文中心检查可以对称扩展多远
            - 注意长度奇偶不同的回文串的中心不同
          - 【TODO】从优化动态规划算法来分析：
            - 分析动态规划方法的转移方程，其状态转移链是这样的：

              $P(i,j) \leftarrow P(i+1,j-1) \leftarrow P(i+2,j-2) \leftarrow ... \leftarrow 边界情况$

              即状态转移链是单分支的，即任意状态的转移都是确定的，只有一个转移方向

            - 因此我们可以从每一种边界开始扩展到该边界能够扩展到的最终状态，这样一种边界能够扩展到的最终状态和中间状态都会被遍历计算到，当把所有可能的边界遍历完，则所有状态都被枚举并计算，也就完成了动态规划的全部计算
            - 而边界情况就是所有的单个字符或双字符，扩展方法就是以单字符或双字符为回文中心向两边检查是否对称
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)

    - 【Manacher（马拉车）】
      - 分析
        - 【TODO】
          - 就像KMP回溯算法的基本思想一样，当我们遍历某个字符作为回文中心的时候，我们对它其实并非一无所知，我们可以从之前遍历到的字符中得到关于它的信息
          - “回文臂”是回文中心到回文串头或尾的半径，则奇数回文串的长度是两倍臂长加一，偶数回文串是两倍臂长。请注意右侧回文臂内的每个字符在左侧回文臂内都有对应相等的字符，且这两个字符左右两侧紧邻的部分字符也是相等的。所以当我们从右侧回文臂选择任一个符作为回文中心时，都可以从左侧回文臂内我们曾遍历过的字符中获取历史信息
          - 具体来说就是当我们把某个字符$s_j$作为回文中心并发现回文串后，枚举回文臂内任一字符$s_i$作为回文中心时，都可以复用另一侧回文臂对应的字符$s_{2j-i}$被作为回文中心遍历时的信息即以$s_{2j-i}$为回文中心的回文臂长$L_{2j-i}$
          - 因为回文串的对称性，以$s_i$作为回文中心时，可以直接跳过两侧$L_{2j-i}$个字符，直接从$(i-L_{2j-i}-1, i+L_{2j-i}+1)$的对子开始比对。但要注意的是我们的已知信息来源于以$s_j$为中心的回文串，因此已知范围在回文臂范围内，而$s_{2j-i}$为中心的回文串是有可能有部分串不在$s_j$回文串内的，所以在计算可以跳过的字符数量时要做限制：$min(L_{2j-i}, j+L_{j}-i)$
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
