# 断言区间

- [26.删除有序数组中的重复项](questions/accepted/26.删除有序数组中的重复项.rs)：
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
    - 【有序】因为数组是有序的，重复项必定相邻
  - 分析：TODO
  - 解法
    - 【双指针】Time=O(n), Space=O(1)
      - 将数组分割成两部分，前一部分不重复，后一部分可能重复
      - 左指针指向不重复数组的末端，左指针之前没有重复，之后可能存在重复
      - 右指针向前探索不断寻找左指针之前没有的值，然后将其加入左指针之前的数组，左指针则配合着前进一步来扩大不重复数组范围

- [125.验证回文串](questions/accepted/125.验证回文串.rs)
  - 条件
    - 【ASCII字符串】
  - 分析：TODO
  - 解法
    - 【双指针】Time=O($log_2n$), Space=O(1)
      1. 左指针指向字符串头，右指针指向字符串尾，左右指针相向移动，步长为1
      1. 左右指针都跳过非字母的字符
      1. 检查左右指针指向的字符值是否相等
         - 若相等，左右指针移动一步，回到(2)
         - 若不等，则不是回文串，返回结果
      1. 重复(2)(3)直到左指针和右指针相等或交错

- [283.移动零](questions/accepted/283.移动零.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：TODO
  - 解法
    - 【双指针】Time=O(n), Space=O(1)
      - 将数组分割成两部分，前一部分没有0，后一部分可能有0
      - 左指针指向非0数组的末端，左指针之前没有0，之后可能存在0
      - 右指针向前探索不断寻找非0值，然后将其加入左指针之前的数组，左指针则配合着前进一步来扩大不重复数组范围

- [344.反转字符串](questions/accepted/344.反转字符串.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：TODO
  - 解法
    - 【双指针】Time=O(n), Space=O(1)
      - 左指针从数组头开始，右指针从数组尾开始
      - 交换两个指针所指的值
      - 左指针向尾移动一步，右指针向头移动一步

- [75.颜色分类](https://leetcode-cn.com/problems/sort-colors/)（[我的实现](questions/accepted/75.颜色分类.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 借鉴快排的“维护有序区间”的思想，开辟至少两个有序区间并不断扩展维护，直到两个有序区间扩展到极限，将所有属于该区间的元素都吸纳进来后，剩下的那个原本无序的区间也会变成有序区间
  - 解法
    - 【TODO】
      - 分析
        - 【TODO】
          - 在数组的头部开辟两个向尾部扩展的有序区间，一个是纯0区间，一个是纯1区间，遍历到0就和0区间尾交换，遍历到1就和1区间尾交换，交换后遍历迭代到下一步
          - 需要注意的是，1区间是堆叠在0区间后面的，因此当1区间非空时，扩展0区间会把1区间的元素交换出来。为了避免这个问题，当1区间非空时，交换0元素后，还要把交换出来的1再跟1区间尾元素交换
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
    - 【TODO】
      - 分析
        - 【TODO】
          - 在数组的头部开辟向尾部扩展的纯0区间，在数组尾部开辟向头部扩展纯2区间，遍历到0就和0区间尾交换，遍历到2就和2区间尾交换，交换后遍历迭代到下一步
          - 令$p_0$代表0区间尾，$p_2$代表2区间尾，$i$代表遍历指针，则：
            - $p_0 \leq i \leq p_2$必然成立
            - 对于$a_i$的值：
              - $a_i = 0$
                - $i = p_0$：遍历元素紧邻0区间，发现的0就在0区间下一次扩展要使用的空间中，此时交换相当于直接扩展0区间
                - $i > p_0$：遍历元素和0区间之间穿插了许多1，此时交换相当于把紧邻0区间、占用了0区间下一次扩展空间的1和遍历发现的0交换
              - $a_i = 2$

                2区间不像0区间那样隐含了约束“遍历元素与0区间之间只有1（纯1有序区间）”，因此遍历元素可能与紧邻2区间的非1元素（$a_{p2-1}=0或2$）进行了交换

                - $a_{p2-1} = 2$：此时需要不断循环遍历元素并同时扩展2区间直到遍历到非2元素（0或1）。需要注意的是，遇到0元素还要将其添加到0区间
                - $a_{p2-1} = 0$：此时不能直接遍历下一个元素，需要将0元素添加到0区间
      - 算法

        ```TODO
        ```

      - 复杂度
        - 时间：O(TODO)
        - 空间：O(TODO)
