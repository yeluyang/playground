# 哈希

最优解为哈希的问题一般有如下特性：

- 【集合环境依赖】集合中某个元素的条件判定与集合内其他元素或其他集合有关

- [1.两数之和](questions/accepted/1.两数之和.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：
    - 【集合环境依赖】
      - 数组内某元素是不是两数和组成部分的判定，取决于数组内其他元素的状态，具体来说就是有无一个元素与该元素的和恰好是目标值
  - 解法
    - 【哈希】Time=O(n), Space=O(n)
      - 构建一个以元素值为键，元素值下标为值的哈希表
      - 遍历每个元素，计算目标值减去元素的差值是否在表中：
        - 若存在，则返回该键的值与当前元素下标值组成的二元组
        - 若不存在，则插入以元素值为键，元素下标为值的键值对入表

- [217.存在重复元素](questions/accepted/217.存在重复元素.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析：
    - 【集合环境依赖】
      - 一个数组是否存在重复元素的判定，可以解释为数组中各个元素是否重复的判定
      - 数组中某元素是否重复的判定，取决于数组内其他元素的状态，具体来说就是其他元素的值有没有和该元素相同的
  - 解法
    - 【哈希】Time=O(n), Space=O(n)
      - 对每个元素，将其插入集合中，若发现集合中已存在，则存在重复元素

- [242.有效的字母异位词](questions/optimizable/242.有效的字母异位词.rs)
  - 条件
    - 【ASCII字符串】
  - 分析：
    - 【集合环境依赖】
      - 两个字符串是否为字母异位词的判定，可以解释为一个串中每个字符值出现次数是否与另一串等同
      - 一个串中某字符的值是否在交集内的判定，取决于该数组内其他元素的状态以及另一数组内元素的状态，具体来说就是当前数组内的同值元素和另一数组内的同值元素出现次数
  - 解法
    - 【哈希】Time=O(n), Space=O($\Sigma$)
      - 构建一个以字符值为键，字符出现次数为值的哈希表
      - 遍历其中一个字符串，将字符出现频次统计入哈希表
      - 遍历另一个字符串：
        - 字符值不在哈希表中，则不是异位词，返回结果
        - 字符值在哈希表中则对应的出现次数-1，若-1后为0，则移除该键值对
      - 遍历结束后，若哈希表为空，则为异位词

- [350.两个数组的交集-ii](questions/accepted/350.两个数组的交集-ii.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析
    - 【集合环境依赖】
      - 一个数组某元素是否在交集内的判定，取决于该数组内其他元素的状态以及另一数组内元素的状态，具体来说就是当前数组内的同值元素和另一数组内的同值元素出现次数
  - 解法
    - 【哈希】Time=O(m + n), Space=O( min(m, n) )
      - 使用以元素值为键，出现次数为值的哈希表
      - 遍历较短的数组，记录每个元素的出现次数
      - 遍历另一数组，对存在于哈希表中的元素，将元素记录到返回结果中，并将次数-1。若次数-1后为0，则从哈希表移除该元素

- [387.字符串中的第一个唯一字符](questions/accepted/387.字符串中的第一个唯一字符.rs)
  - 条件
    - 【ASCII字符串】
  - 分析
    - 【集合环境依赖】
      - 字符串中的某个字符是否唯一的判定，取决于字符串内其他字符的状态，具体来说就是其他字符有没有和该字符相同的
  - 解法
    - 【哈希】Time=O(n), Space=O($\Sigma$)
      - 构建一个以元素值为键，元素出现次数为值的哈希表
      - 遍历字符串，统计元素出现次数到哈希表中
      - 遍历哈希表，遇到次数为1的元素记录就返回结果

- [49.字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/solution/)（[我的实现](questions/wrong/49.字母异位词分组.rs)）
  - 条件
    - 【TODO】
  - 分析
    - 【TODO】
      - 字母异位词的长度一致，用到的字母一致，包括某个字母重复次数也一致
  - 解法
    - 【排序+哈希】
      - 分析
        - 【TODO】
          - 字母异位词意味着它们排序后完全相同，因此可以每个词排序后的值作为映射的键，将异位词数组作为映射的值
      - 算法

        ```TODO
        ```

      - 复杂度：n是输入字符串数量，k是输入字符串中最长的串的长度
        - 时间：O($nklog_2k$)
        - 空间：O($nk$)

    - 【计数+哈希】
      - 分析
        - 【TODO】
          - 字母异位词意味着每个字母的出现次数是一样的，可以用一个长度等于字母表长度的辅助空间记录每个词的每个字母出现次数，并以每字母出现次数为映射的键，将异位词数组作为映射的值
      - 算法

        ```TODO
        ```

      - 复杂度：n是输入字符串数量，k是输入字符串中最长的串的长度，$\Sigma$是字母表长度
        - 时间：O($n(k+\Sigma)$)
        - 空间：O($n(k+\Sigma)$)

## 哈希+状态位串

- [36.有效的数独](questions/accepted/36.有效的数独.rs)
  - 条件
    - 【数组】数据存储结构为纯数组，可以任意顺序读取或随机读取。尾部插入删除操作开销低，其他位置插入删除操作开销大
  - 分析
    - 【集合环境依赖】
      - 数独是否有效的判定，可以解释为数独矩阵每个数字是否有效的判定
      - 数度矩阵每个元素是否有效的判定，可解释为该元素在三个集合中是否有效的判定
      - 每个元素在对应的三个集合中是否有效的判定，取决于三个集合内部其他元素的状态。具体来说该元素值对应的列集合、行集合和宫集合的其他元素有无重复值
    - 【定长布尔状态集】
      - 因为三个元素状态集只需要记录元素是否存在即可，可解释为布尔值
      - 又因为元素的键值就是元素值本身而其值域只有1-9，是固定且较小的值域
      - 所以可以用一个长度合适的位串来记录元素状态，元素键值映射对应的位是0还是1来记录元素是否存在
  - 解法
    - 【哈希】+【布尔串】Time=O(a * a), Space=O(a + a + a)
      - 构建三个哈希表：
        - 行哈希表：以行号为键，以位数大于等于列数a的位串为值
        - 列哈希表：以列号为键，以位数大于等于行数a的位串为值
        - 宫哈希表：以宫号为键，以位数大于等于宫数a的位串为值
      - 遍历矩阵每个元素(i,j)：
        - 将1按位右移，偏移量等于该元素值，所得结果作为元素模式
        - 元素模式与行哈希表第i行对应的位串按位与操作：
          - 结果==0：将元素模式以按位或操作的方式更新到行哈希表第i行对应的位串
          - 结果!=0：判别为无效数独并返回结果
        - 元素模式与列哈希表第j列对应的位串按位与操作：
          - 结果==0：将元素模式以按位或操作的方式更新到列哈希表第j列对应的位串
          - 结果!=0：判别为无效数独并返回结果
        - 元素模式与宫哈希表第(i/3+j/3)宫对应的位串按位与操作：
          - 结果==0：将元素模式以按位或操作的方式更新到宫哈希表第(i/3+j/3)宫对应的位串
          - 结果!=0：判别为无效数独并返回结果
